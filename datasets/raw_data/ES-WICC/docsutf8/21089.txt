B√∫squedas en bases de datos de texto y bases de datos m√©tricas
Ôªø
Con la evoluci√≥n de las tecnolog√≠as de informaci√≥n y comunicaci√≥n, han surgido almacenamientos no estructurados de informaci√≥n. No s√≥lo se consultan nuevos tipos de datos tales
como texto libre, im√°genes, audio y video; sino que adem√°s, en algunos casos, ya no se puede
estructurar m√°s la informaci√≥n en claves y registros. Estos escenarios requieren modelos m√°s
generales tales como bases de datos de texto o bases de datos m√©tricas.
La necesidad de una respuesta r√°pida y adecuada, y un eficiente uso de memoria, hace necesaria la existencia de estructuras de datos especializadas que incluyan estos aspectos. En particular, nos vamos a dedicar a dos tipos de bases de datos: las Bases de Datos M√©tricas y las Bases
de Datos de Texto, y c√≥mo resolver eficientemente no s√≥lo las b√∫squedas en esos √°mbitos, sino
tambi√©n algunas otras operaciones de inter√©s en el √°rea de bases de datos. As√≠, la investigaci√≥n
apunta a poner estas nuevas bases de datos a un nivel de madurez similar al de las tradicionales.
1. Introducci√≥n y Motivaci√≥n
Con la evoluci√≥n de las tecnolog√≠as de informaci√≥n y comunicaci√≥n, han surgido almacenamientos
no estructurados de informaci√≥n. No s√≥lo se consultan nuevos tipos de datos tales como texto libre,
im√°genes, audio y video; sino que adem√°s, en algunos casos, ya no se puede estructurar m√°s la informaci√≥n en claves y registros. A√∫n cuando sea posible una estructuraci√≥n cl√°sica, nuevas aplicaciones
tales como la miner√≠a de datos requieren acceder a la base de datos por cualquier campo y no s√≥lo por
aquellos marcados como ‚Äúclaves‚Äù.
Los escenarios anteriores requieren modelos m√°s generales tales como bases de datos de texto
o bases de datos m√©tricas (es decir, bases de datos que incluyan objetos de un espacio m√©trico),
entre otros; y contar con herramientas que permitan realizar b√∫squedas eficientes sobre estos tipos
de datos. Las t√©cnicas que emergen desde estos campos muestran un √°rea de investigaci√≥n propicia
para el desarrollo de herramientas que resuelvan eficientemente los problemas involucrados en la
administraci√≥n de estos tipos de bases de datos no convencionales.
La b√∫squeda por similitud es un tema de investigaci√≥n que abstrae varias nociones de las ya mencionadas. Este problema se puede expresar como sigue: dado un conjunto de objetos de naturaleza
desconocida, una funci√≥n de distancia definida entre ellos, que mide cuan diferentes son, y dado otro
objeto, llamado la consulta, encontrar todos los elementos del conjunto suficientemente similares a la
consulta. El conjunto de objetos junto con la funci√≥n de distancia se denomina espacio m√©trico [3].
Este trabajo ha sido financiado parcialmente por el Proyecto RIBIDI CYTED VII.19 (todos los autores), por el Centro
del N√∫cleo Milenio para Investigaci√≥n de la Web, Grant P01-029-F, Mideplan, Chile (pen√∫ltimo autor) y por la Comisi√≥n
Nacional de Investigaci√≥n Cient√≠fica y Tecnol√≥gica (CONICYT), convenio BIRF/Gobierno de Chile (primer autor).
1De licencia en la U.N.S.L., se encuentra realizando el doctorado en la Universidad de Chile.
Por otra parte, una base de datos de texto es un sistema que debe proveer acceso eficiente a
grandes vol√∫menes de texto no estructurado, donde existe la necesidad de construir √≠ndices que no
s√≥lo permitan realizar b√∫squedas eficientes de patrones ingresados por el usuario, sino que adem√°s
usen tan poco espacio como sea posible. El texto se puede ver como una secuencia de s√≠mbolos y el
patr√≥n a buscar como otra m√°s breve, y as√≠ el problema de b√∫squeda consiste en encontrar todas las
apariciones del patr√≥n en el texto, y en algunos casos admitiendo un n√∫mero peque√±o de errores.
La necesidad de una respuesta r√°pida y adecuada, y un eficiente uso de memoria, hace necesaria
la existencia de estructuras de datos especializadas que incluyan estos aspectos. En particular, nos
vamos a dedicar a dos tipos de bases de datos: las Bases de Datos M√©tricas y las Bases de Datos de
Texto, y c√≥mo resolver eficientemente no s√≥lo las b√∫squedas en esos √°mbitos, sino tambi√©n algunas
otras operaciones de inter√©s en el √°rea de bases de datos. Por lo tanto, la investigaci√≥n apunta a poner
estas nuevas bases de datos a un nivel de madurez similar al de las bases de datos tradicionales.
2. Espacios M√©tricos
El planteo general del problema es: dado un conjunto S  U , recuperar los elementos de S que
sean similares a uno dado, donde la similitud entre elementos es modelada mediante una funci√≥n de
distancia positiva d. El conjunto U denota el universo de objetos v√°lidos y S , un subconjunto finito de
U , denota la base de datos en donde buscamos. El par (U ; d) es llamado espacio m√©trico. La funci√≥n
d : U  U ! R
+ cumple con las propiedades propias de una funci√≥n de distancia. B√°sicamente,
existen dos tipos de b√∫squedas de inter√©s en espacios m√©tricos:
B√∫squeda por rango: recuperar todos los elementos de S a distancia r de un elemento q dado.
B√∫squeda de los k vecinos m√°s cercanos: dado q, recuperar los k elementos m√°s cercanos a q.
2.1. Bases de Datos M√©tricas
Integrar objetos de un espacio m√©trico en un ambiente de bases de datos requiere principalmente poder
resolver consultas por similaridad eficientemente. En aplicaciones reales es posible tener grandes
vol√∫menes de datos, ya sea por la cantidad de objetos o por el tama√±o de cada objeto. Ello implica
que debemos contar con estructuras adecuadas y eficientes para memoria secundaria. Adem√°s en un
escenario real de un ambiente de base de datos es necesario contar con herramientas que permitan
trabajar con grandes vol√∫menes de datos y usualmente ser√≠an din√°micas. Es decir, deber√≠an permitir
insertar, o eliminar objetos din√°micamente, por lo tanto los √≠ndices deber√≠an soportar estas operaciones eficientemente. Un objeto de un espacio m√©trico puede ser una imagen, una huella digital, un
documento, o cualquier otro tipo de objeto. Esto tambi√©n implica que las operaciones sobre datos de
un espacio m√©trico son, en general, m√°s costosas que las operaciones relacionales est√°ndar.
Existen √≠ndices que, en principio, no s√≥lo resuelven ambos tipos de problemas; pero a√∫n est√°n
muy inmaduros para ser usados en la vida real por dos motivos importantes: falta de dinamismo y
necesidad de trabajar en memoria principal. Estas caracter√≠sticas son sobreentendidas en los √≠ndices
para bases de datos tradicionales, y la investigaci√≥n apunta a poner los √≠ndices para estas nuevas bases
de datos a un nivel de madurez similar.
Hemos desarrollado una estructura para b√∫squeda por similitud en espacios m√©tricos llamado
√Årbol de Aproximaci√≥n Espacial Din√°mico (SATD) [6] que permite realizar inserciones y eliminaciones, manteniendo una buen desempe√±o en las b√∫squedas. Muy pocos √≠ndices para espacios
m√©tricos son completamente din√°micos. Estamos actualmente desarrollando una versi√≥n del SATD
que funcione adecuadamente en memoria secundaria, manteniendo su buen desempe√±o en las b√∫squedas
y el dinamismo. As√≠, ser√≠a posible pensar en extender apropiadamente el √°lgebra relacional y dise√±ar
soluciones eficientes para los nuevos operadores, teniendo en cuenta aspectos no s√≥lo de memoria secundaria, sino tambi√©n de concurrencia, confiabilidad, etc. Algunos ejemplos de las operaciones que
podr√≠an ser de inter√©s resolver son: join espacial, operaciones de conjuntos y otras operaciones de inter√©s en bases de datos espaciales tales como los operadores topol√≥gicos. Algunos de estos problemas
ya poseen soluci√≥n en las bases de datos espaciales, pero no en el √°mbito de los espacios m√©tricos.
3. Bases de Datos de Texto
Una base de datos de texto es un sistema que provee acceso eficiente a amplias masas de datos textuales. El requerimiento m√°s importante es que desarrolle b√∫squedas r√°pidas para patrones ingresados
por el usuario. En general el escenario m√°s simple aparece es como sigue: el texto T
1:::u
se ve como
una √∫nica secuencia de caracteres sobre un alfabeto  de tama√±o , y el patr√≥n de b√∫squeda P
1:::m
como otra (breve) secuencia sobre . Luego pueden aparecer dos problemas de b√∫squeda de texto:
(1) consiste en encontrar todas las ocurrencias de P en T y (2) consiste en encontrar todas las ocurrencias de P en T que contengan a lo m√°s r errores, es decir todos los substrings de T cuya distancia
de edici√≥n (o distancia de Levenshtein) a P sea a lo m√°s r.
En la actualidad las bases de datos de texto tienen que enfrentar dos objetivos opuestos. Por un
lado, tienen que proveer acceso r√°pido al texto y por el otro, tienen que usar tan poco espacio como
sea posible. Los objetivos son opuestos debido a que para proveer acceso r√°pido se debe construir un
√≠ndice sobre el texto. Un √≠ndice es una estructura de datos construida sobre el texto y almacenada en la
base de datos y as√≠ incrementa los requerimientos de espacio. Recientemente se ha investigado mucho
sobre bases de datos de texto comprimido, enfoc√°ndose en comprimirlo y, de ser posible, hacerlo de
tal forma que las estructuras que representan al texto comprimido nos sirvan tambi√©n para buscar en
√©l. Un ejemplo de este tipo de √≠ndice es el LZ-Index [5].
Por otra parte, existen muchas aplicaciones en las cuales tiene sentido buscar todas las ocurrencias
de un patr√≥n P , pero admitiendo que nuestras respuestas contengan algunos errores. En este caso no
son √∫tiles los √≠ndices que se construyen para resolver el caso (1), sino que hay que dise√±ar nuevos
√≠ndices que permitan responder eficientemente esta clase de consulta.
3.1. B√∫squeda de Texto con Errores
Un problema abierto en la b√∫squeda combinatoria de patrones es la indexaci√≥n del texto para permitir
b√∫squeda aproximada sobre √©l. El problema de b√∫squeda aproximada es: dado un gran texto T de
longitud n y un patr√≥n P de longitud m (comparativamente m√°s corto) y un valor r, devolver todas las
ocurrencias del patr√≥n, es decir, todos los substrings cuya distancia de edici√≥n a P es a lo sumo r. La
distancia de edici√≥n entre dos strings se define como la m√≠nima cantidad de inserciones, supresiones
o substituciones de caracteres necesaria para que los strings sean iguales. Esta distancia es usada en
muchas aplicaciones, pero cualquier otra distancia puede ser de inter√©s.
Hay variadas soluciones al problema de b√∫squeda aproximada basadas en el preprocesamiento del
patr√≥n pero no del texto, y como el tiempo de b√∫squeda es proporcional al tama√±o del mismo no son
aceptables cuando el texto es muy grande. Recientemente ha recibido mayor atenci√≥n la posibilidad
de indexar el texto para la b√∫squeda aproximada de strings. Sin embargo, la mayor√≠a de los esfuerzos
se orientan a la b√∫squeda en textos de lenguaje natural y las soluciones no se pueden extender a casos
generales como ADN, prote√≠nas, s√≠mbolos orientales, etc.
La presente aproximaci√≥n [2] considera que la distancia de edici√≥n satisface la desigualdad triangular y as√≠ esto define un espacio m√©trico sobre el conjunto de substrings de T . Entonces se puede
replantear el problema como un problema de b√∫squeda por rango sobre un espacio m√©trico.
Una propuesta de indexaci√≥n del texto para b√∫squeda aproximada de strings, usando t√©cnicas de
espacios m√©tricos, tiene el problema que hay O(n2) diferentes substrings en un texto y adem√°s habr√≠a
que indexar O(n2) objetos, lo cual es inaceptable. En esta aproximaci√≥n la idea es indexar los n
sufijos del texto. Cada sufijo [T
j:::
‚ÑÑ representa todos los substrings que comienzan en la posici√≥n j.
Existen diferentes opciones de c√≥mo indexar este espacio m√©trico formado por O(n) conjuntos de
strings, la elegida aqu√≠ es una propuesta basada en pivotes. Entonces seleccionamos k pivotes y para
cada conjunto de sufijos [T
j:::
‚ÑÑ del texto y cada pivote p
i
, computamos la distancia entre p
i
y todos los
strings representados por [T
j:::
‚ÑÑ. De ese conjunto de distancias desde [T
j:::
‚ÑÑ a p
i
, se almacena s√≥lo la
m√≠nima obtenida, o sea s√≥lo los k valores de las distancias m√≠nimas de los substrings a los k pivotes.
Notar que no necesitamos construir ni guardar los sufijos, ya que ellos se pueden obtener e indexar
directamente del texto. As√≠, la √∫nica estructura necesaria ser√≠a el √≠ndice m√©trico.
Si se considera la b√∫squeda de un patr√≥n dado P con a lo sumo r errores se est√° ante un query
por rango de radio r en el espacio m√©trico de sufijos. Como en todos los algoritmos basados en
pivotes comparamos el patr√≥n P contra los k pivotes y obtenemos una coordenada k-dimensional
(ed(P; p
1
); : : : ; ed(P; p
k
)).
Sea p
i
un pivote dado y los sufijos [T
j:::
‚ÑÑ de T , si se cumple que ed(P; p
i
)+r < min(ed([T
j:::
‚ÑÑ; p
i
)),
por la desigualdad triangular se sabe que ed(P; [T
j:::
‚ÑÑ)) > r para todo substring que est√© representado
por [T
j:::
‚ÑÑ. La eliminaci√≥n se puede hacer usando cualquier pivote p
i
. Al buscar qu√© sufijos podr√°n
ser eliminados se cae en un cl√°sico problema de b√∫squeda por rango en un espacio multidimensional,
as√≠ para esta tarea se podr√≠a usar el R-tree, o alguna de sus variantes. Los nodos que no puedan ser
eliminados usando alg√∫n pivote deber√°n ser directamente comparados contra P y para aquellos cuya
distancia m√≠nima a P sea a lo sumo r, se reportar√°n todas sus ocurrencias.
Algunas aspectos que estamos considerando actualmente incluyen:
 Como ya se ha realizado la implementaci√≥n de la aproximaci√≥n presentada, estamos actualmente realizando experimentos para analizar su competitividad.
 Mejorar esta propuesta bas√°ndonos en el conocimiento de que los pivotes con distancias m√≠nimas
grandes permiten la eliminaci√≥n de una mayor cantidad de sufijos.
 Analizar otra posible mejora basada en tomar un primer pivote, determinar sus s sufijos m√°s
lejanos, almacenar esos sufijos y sus distancias m√≠nimas en una lista en forma ordenada y
luego descartar esos sufijos para pr√≥ximas consideraciones. Esta idea puede ser eficiente y
competitiva en una implementaci√≥n en memoria secundaria.
3.2. B√∫squeda de Texto sin Errores
La estructura de datos LZ‚ÄìIndex est√° basada en el trie producido por el algoritmo de compresi√≥n de
Ziv‚ÄìLempel (m√°s precisamente en el algoritmo LZ78 [1]). La idea de la compresi√≥n de Ziv‚ÄìLempel
es reemplazar substrings del texto por punteros a apariciones anteriores de dichos substrings. Si el
puntero ocupa menos espacio que el substring que reemplaza, entonces se logr√≥ compresi√≥n.
Para buscar un patr√≥n P en T de manera eficiente, la idea de LZ‚ÄìIndex es usar el mismo trie
producido por LZ78 m√°s algunas estructuras de datos adicionales que a detallamos a continuaci√≥n:
LZTrie: es el trie formado por los bloques B
0
: : : B
n
. RevTrie: es el trie formado por todos los strings
reversos Br
0
: : : B
r
n
. Node: es un mapeo de identificadores de bloque a su nodo en LZTrie. RNode: es
un mapeo de identificadores de bloque a su nodo en RevTrie.
Una caracter√≠stica importante de LZ‚ÄìIndex es que es un √≠ndice comprimido; luego de construir las
estructuras de datos antes mencionadas, las mismas son comprimidas y el texto T puede ser borrado
por completo, pudi√©ndose recuperar usando el √≠ndice (self-indexing). Esto es muy importante en la
pr√°ctica ya que se requiere poca memoria para mantener el √≠ndice, a diferencia de las estructuras de
datos tradicionales como los √°rboles y arreglos de sufijos.
Sin embargo, la construcci√≥n de LZ‚ÄìIndex a√∫n requiere demasiada memoria, porque √©sta se basa
en representaciones no comprimidas de las estructuras de datos que conforman el √≠ndice. En los
experimentos de [5], el espacio necesario para construir el √≠ndice fue para lenguaje natural entre 4.8
a 5.8 veces y para ADN entre 3.4 a 3.7 veces el tama√±o de T . Como comparaci√≥n, la construcci√≥n
de un arreglo de sufijos plano (sin ninguna estructura de datos extra) requiere un espacio de 5 veces
el tama√±o de T . La diferencia est√° en que, luego de construido, LZ‚ÄìIndex requiere de poca memoria,
pero los arreglos de sufijos requieren siempre el mismo espacio.
Actualmente estamos trabajando en un algoritmo de construcci√≥n de LZ‚ÄìIndex que requiera poca
memoria. La idea principal consiste en reemplazar las representaciones intermedias de LZTrie y
RevTrie por representaciones que sean eficientes en el uso de espacio. Una idea es emplear la representaci√≥n lineal de par√©ntesis balanceados de Munro y Raman [4]. Sin embargo, el problema de
usar esta representaci√≥n lineal es que debe ser recomputada por completo ante cada inserci√≥n de un
nuevo nodo, lo cual es muy costoso. Para evitar este problema, hemos definido una representaci√≥n
jer√°rquica de par√©ntesis balanceados, de manera tal de tener que recomputar s√≥lo una peque√±a parte
de la secuencia ante una inserci√≥n. Esto es implementado como un √°rbol de p√°ginas, en donde cada
p√°gina implementa una subsecuencia de par√©ntesis balanceados.
Hasta el momento hemos trabajado en definir un m√©todo para garantizar un cierto porcentaje de
ocupaci√≥n de las p√°ginas del √°rbol, y as√≠ reducir el desperdicio de memoria y otro m√©todo para el
tratamiento de rebalse de las p√°ginas y un algoritmo de compresi√≥n de caminos unarios vac√≠os para
reducir los requerimientos de espacio en la construcci√≥n del trie reverso.
Actualmente estamos implementando las propuestas con el fin de evaluarlas emp√≠ricamente en
cuanto al tiempo y espacio requerido para la construcci√≥n. Se espera que el m√©todo propuesto reduzca
significativamente los requerimientos de memoria al construir LZ‚ÄìIndex. Adem√°s, planeamos realizar
el an√°lisis te√≥rico de la propuesta, para obtener garant√≠as te√≥ricas de la eficiencia del algoritmo.
Algunas l√≠neas de investigaci√≥n futura incluyen:
 Reducir el espacio requerido por LZ‚ÄìIndex eliminando algo de la redundancia que agregan
algunas de las estructuras de datos que conforman el √≠ndice (sobre todo Node y RNode).
 Obtenci√≥n de un prototipo de LZ‚ÄìIndex para memoria secundaria.
 Permitir el agregado de texto en el √≠ndice, como paso previo para el dinamismo total del √≠ndice.
