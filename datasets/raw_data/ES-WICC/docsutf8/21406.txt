B√∫squedas por similitud en espacios m√©tricos el FQtrie
ÔªøB√∫squedas por Similitud en Espacios M√©tricos: el FQtrie 
Edgar L. Ch√°vez Norma E. Herrera, Carina M. Ruano, Ana V. Villegas
Escuela de Ciencias F√≠sico - Matem√°ticas Departamento de Inform√°tica
Universidad Michoacana - M√©xico Universidad Nacional de San Luis
elchavez@fismat.umich.mx nherrera,cmruano,anaville@unsl.edu.ar
Fax: +54 (2652) 430224
1 Introducci√≥n
La b√∫squeda de elementos cercanos o similares a uno dado, es un problema que aparece en diversas
√°reas. Este concepto fue motivado como una extensi√≥n natural del concepto de b√∫squeda exacta, ante
el surgimiento de nuevos tipos de bases de datos tales como base de datos de im√°genes, de sonido, de
texto, etc.
Las bases de datos tradicionales se construyen bas√°ndose en el concepto de b√∫squeda exacta: la
base de datos es dividida en registros y cada registro contiene campos completamente comparables.
Las consultas a la base de datos retornan todos aquellos registros cuyos campos coinciden con los
aportados en tiempo de b√∫squeda.
Estructurar datos no tradicionales (tales como im√°genes, sonido, video, etc.) en registros para adecuarlos al concepto tradicional de b√∫squeda exacta, es dif√≠cil en muchos casos y hasta imposible si
la base de datos cambia m√°s r√°pido de lo que se puede estructurar (como por ejemplo la web). Aun
cuando pudiera hacerse, las consultas que se pueden satisfacer con la tecnolog√≠a tradicional, est√°n
limitadas en variaciones de la b√∫squeda exacta.
Nos interesan las b√∫squedas en donde se puedan recuperar objetos similares a uno dado. Este tipo
de b√∫squeda, se conoce con el nombre de b√∫squeda por proximidad o b√∫squeda por similitud, y
surge en √°reas tales como reconocimiento de voz, reconocimiento de im√°genes, compresi√≥n de texto,
recuperaci√≥n de texto, biolog√≠a computacional, etc. La necesidad de una respuesta r√°pida y adecuada,
y un uso eficiente de memoria, hacen necesaria la existencia de estructuras de datos especializadas
que incluyan estos aspectos.
Todas las aplicaciones mencionadas poseen algunas caracter√≠sticas comunes. Existe un universo 
de objetos y una funci√≥n de distancia        que modela la similitud entre los objetos. La
funci√≥n  cumple con las propiedades caracter√≠sticas de una funci√≥n de distancia:
(a)          (positividad)
Este trabajo es parcialmente subvencionado por CYTED VII.19 RIBIDI Project (todos los autores) y por CONACyT
36911-A (Edgar Ch√°vez )
(b)           (simetr√≠a)
(c)               (desigualdad tringular)
El par    es llamado espacio m√©trico [8]. La base de datos es un conjunto finito  	  , el cual
se preprocesa a fin de resolver b√∫squedas por similitud eficientemente.
Existen dos tipos b√°sicos de b√∫squedas por similitud en espacios m√©tricos :
B√∫squeda por rango: consiste en recuperar todos los elementos de  que est√°n a distancia  de un
elemento  dado. En s√≠mbolos,  

 
	     	  
B√∫squeda de los k-vecinos m√°s cercanos: consiste en recuperar los 
 elementos m√°s cercanos a 
en  . Esto significa encontrar un conjunto  	  tal que   
 
 	        
 	   
Un caso particular de espacios m√©tricos son los espacios vectoriales 
-dimensionales, con las funciones de distancia 

:




   

 

   

  




 





     




   

 

   

  



 

   
Para estos casos existen soluciones bien conocidas tales como KD-tree [2], R-tree [9], etc. Sin embargo, √©ste no es el caso general. Las investigaciones en la actualidad tienden al estudio de algoritmos
en espacios m√©tricos generales.
Es claro que, una b√∫squeda por similitud, puede resolverse de forma ineficiente examinando exhaustivamente la base de datos  . Para evitar esto, se preprocesa  usando alg√∫n algoritmo de indexaci√≥n:
un proceso off-line que construye una estructura de datos o √≠ndice, dise√±ada para ahorrar c√°lculos en
el momento de resolver una b√∫squeda.
El tiempo total de resoluci√≥n de una b√∫squeda puede ser calculado de la siguiente manera:
T= #evaluaciones de  complejidad(d) + tiempo extra de CPU + tiempo de I/O
En muchas aplicaciones la evaluaci√≥n de la funci√≥n  es tan costosa, que las dem√°s componentes de
la f√≥rmula anterior pueden ser despreciadas. √âste es el modelo usado en la mayor√≠a de los trabajos
de investigaci√≥n hechos en esta tem√°tica. Sin embargo, hay que prestar especial atenci√≥n al tiempo
extra de CPU, dado que reducir este tiempo produce que en la pr√°ctica la b√∫squeda sea m√°s r√°pida,
aun cuando estemos realizando la misma cantidad de evaluaciones de la funci√≥n . De igual manera, el tiempo de I/O puede jugar un papel importante en algunas aplicaciones, dependiendo de
la memoria principal disponible y del costo relativo de computar la funci√≥n . Los trabajos sobre
espacios m√©tricos, generalmente se han enfocado en algoritmos para descartar elementos en tiempo
de b√∫squeda, dejando de lado las consideraciones sobre el tiempo de I/O. La √∫nica excepci√≥n, ha sido
el MTree [5], dise√±ado espec√≠ficamente para memoria secundaria.
Otro punto importante, es que la mayor√≠a de las estructuras para espacios m√©tricos se construyen bajo
el supuesto de que el conjunto de datos es est√°tico. En muchas aplicaciones esto no es razonable,
dado que los elementos son insertados y eliminados din√°micamente. Algunas estructuras toleran
inserciones pero muy pocas eliminaciones.
2 Algoritmos Basados en Pivotes
B√°sicamente existen dos enfoques para el dise√±o de algoritmos de indexaci√≥n en espacios m√©tricos:
uno est√° basado en Diagramas de Voronoi [1, 8] y el otro est√° basado en pivotes [8].
La idea subyacente de los algoritmos basados en pivotes es la siguiente. Se seleccionan 
 pivotes



 

     

, y se le asigna a cada elemento  de la base de datos, el vector o firma  
 

  

      

.
Ante una b√∫squeda  

, se computa    

  

      

. Luego, se descartan
todos aquellos elementos , tales que para alg√∫n pivote 

,   

  

  , es decir:


  

  

  

  
Esto significa que, todos los algoritmos basados en pivotes, proyectan el espacio m√©trico original, en
un espacio vectorial 
 dimensional con la funci√≥n de distancia 

. La diferencia entre todos ellos,
radica en c√≥mo implementan la b√∫squeda en el espacio mapeado.
La familia de estructuras FQ (FQT, FHQT, FQA, FQtrie) forman parte de las estructuras basadas en
pivotes, y son algunas de las pocas que soportan tanto inserciones como eliminaciones. Cada una de
ellas fue presentada como una mejora de la anterior:
 FQT [4]: construye un √°rbol cuya profundidad depende de la dimensi√≥n del espacio mapeado
(cantidad de pivotes).
 FHQT [3]: es una mejora al FQT. Se construye el √°rbol de manera tal que todas las hojas
est√°n a una misma profundidad. √âsta estructura demostr√≥ experimentalmente ser mejor que su
antecesora en tiempo, pero tiene como desventaja la cantidad de memoria utilizada.
 FQA[7]: produce una mejora importante en el tama√±o del √≠ndice, reemplazando el √°rbol por un
un arreglo ordenado de firmas. El barrido en el √°rbol es simulado por medio de una b√∫squeda
binaria en el arreglo, lo que aumenta en un factor logar√≠tmico la cantidad de c√≥mputos extras
necesarios para resolver la b√∫squeda. El FQA es un enfoque interesante y eficiente si la funci√≥n
de distancia  es muy costosa de calcular. Si esto no es as√≠, entonces el tiempo extra de 
representa una porci√≥n grande del costo.
 FQtrie[6]: es una mejora al FQA, en la que se logra eliminar el factor logar√≠tmico en las
b√∫squedas, utilizando un √°rbol digital para representar el conjunto de firmas de elementos de la
base de datos.
En el caso particular del FQtrie, si bien en su concepci√≥n original permite inserciones y eliminaciones,
hasta el momento no se ha realizado una implementaci√≥n del mismo en la que se incorporen estas
operaciones.
3 Trabajo Futuro
El punto de partida de nuestro trabajo es el . Esta estructura fue presentada recientemente [6]
y por consiguiente no se ha realizado, hasta el momento, un estudio exhaustivo de la misma.
Nos proponemos atacar tres problemas: tiempo extra de CPU, tiempo de I/O y dinamismo. El objetivo
es lograr una implementaci√≥n eficiente (en t√©rminos de tiempo extra de CPU), totalmente din√°mica y
con manejo de espacios m√©tricos cuyo √≠ndice completo exceda la capacidad de la memoria principal.
El trabajo a realizar puede resumirse en los siguientes puntos:
 Con respecto al tiempo extra de CPU, las tablas lookup han demostrado ser una buena opci√≥n
para mejorar el desempe√±o del  y del scan secuencial [6]. Dada una b√∫squeda  

,
una tabla lookup es una estrategia de representaci√≥n de , que permite realizar comparaciones entre palabras de m√°quina completas en lugar de hacerlas por grupos de  bits (donde
 es la cantidad de bits necesitados para codificar  

 ). Utilizaremos esta t√©cnica en la
implementaci√≥n del FQTrie, determinando posibles variaciones de la misma.
 Para el manejo de espacio m√©tricos cuyo √≠ndice completo exceda la capacidad de memoria
principal, en lugar de modificar la estructura para que sea eficiente su manejo en disco, particionaremos el espacio m√©trico, de manera tal que el √≠ndice de cada una de las partes entre en
memoria principal. Luego, una b√∫squeda  

se resuelve buscando separadamente en cada
uno de los √≠ndices, lo que puede ser hecho en memoria principal y en paralelo.
 Con respecto al particionamiento, actualmente estamos analizando distintas posibilidades. En
este sentido, la estrategia de partici√≥n en dos n√∫cleos presentada en [10], ha mostrado un buen
desempe√±o para estructuras basadas en Diagramas de Voronoi, pero presenta algunas debilidades cuando se aplica a estructuras basadas en pivotes. Estamos estudiando el origen de este
problema, para poder, en funci√≥n de ello, dise√±ar una nueva estrategia de partici√≥n, que sea
eficiente para estructuras basadas en pivotes, y que adem√°s sirva para dividir el espacio en una
cantidad arbitraria de partes.
 Como nos proponemos realizar una implementaci√≥n din√°mica del FQtrie, el realizar inserciones
y eliminaciones puede provocar desbalances en las cardinalidades de las partes. Esto debe ser
tomado en cuenta a fin de decidir el momento y el modo apropiado para reorganizar la partici√≥n.
Como producto final, se obtendr√° una implementaci√≥n del FQTrie, eficiente en t√©rminos de tiempo
extra de CPU, totalmente din√°mica y con manejo de espacios m√©tricos en disco.
