Coordinando componentes
Ôªø
En la construcci√≥n de aplicaciones a partir de componentes software es necesario entender
como interact√∫an las componentes de manera individual con su entorno y especificar como
deber√≠a integrarse para que su composici√≥n se comporte como un todo coordinado. En este
sentido es de principal importancia la detecci√≥n temprana de problemas de compatibilidad
entre componentes. En este proyecto proponemos el uso de un modelo de coordinaci√≥n basado
en canales Reo, como un mecanismo para describir el comportamiento interactivo de componentes software, orientado a resolver problemas de interoperabilidad y analizamos su potencia
expresiva compar√°ndolo con otras alternativas basadas en otros modelos de coordinaci√≥n.
Palabras clave: Componentes, coordinaci√≥n, expresividad, interoperabilidad.
1. Introducci√≥n
Construir aplicaciones a partir de componentes software existentes sigue siendo un desaf√≠o importante en el campo de la Ingenier√≠a de software. Su importancia surge por el continuo crecimiento
de la provisi√≥n y demanda de software para Internet y la computaci√≥n m√≥vil. Utilizar componentes
significa comprender como interact√∫an de manera individual con su entorno y especificar como deber√≠an ser sus interacciones mutuas y cooperativas para que su composici√≥n sea correcta [11]. Por
otro lado al trabajar con componentes heterog√©neas, uno de los objetivos a lograr es conseguir una
separaci√≥n clara entre los aspectos de interacci√≥n y computaci√≥n, para as√≠ favorecer la reutilizaci√≥n
y el an√°lisis global de la aplicaci√≥n. En este contexto se manifiesta la necesidad de disponer de
modelos de coordinaci√≥n [3, 10] que puedan ser utilizados para describir expl√≠citamente protocolos
de coordinaci√≥n complejos en t√©rminos de primitivas simples y constructores.
Reo es un modelo de coordinaci√≥n basado en canales en el cual la comunicaci√≥n s√≥lo es posible
1
en presencia de conectores [4]. El car√°cter composicional de los conectores y la posibilidad de su
reconfiguraci√≥n din√°mica, junto a la disponibilidad de una amplia variedad de tipos de canales
con sem√°nticas diferentes de las tradicionales, y las propiedades formales de su c√°lculo coinductivo
ponen de manifiesto la potencia expresiva del lenguaje. Nos interesa tratar el problema de la interoperabilidad de componentes a nivel de protocolos de interacci√≥n, es decir atendiendo a la forma
en que los servicios ofrecidos y requeridos por las componentes deben ser utilizados. Un lenguaje
de alto nivel de abstracci√≥n basado en Reo, con esta capacidad permitir√≠a, a partir del an√°lisis de
las descripciones, determinar de forma anticipada la compatibilidad entre componentes, e incluso
la reemplazabilidad, asegurando as√≠ el correcto ensamblado de los sistemas basados en componentes. Actualmente existen varias propuestas en este sentido y se han definido formalismos que
establecen relaciones para medir el nivel de compatibilidad entre componentes, utilizando √°lgebras
de procesos y determinados modelos de coordinaci√≥n [7, 8, 9, 12].
Por otro lado con el objetivo de analizar la potencia expresiva del modelo, realizamos un estudio
comparativo de diversos modelos de coordinaci√≥n utilizados en la descripci√≥n del comportamiento
de componentes. En particular, trabajamos sobre el modelo basado en canales y el modelo basado
en datos. Para ello aplicamos la noci√≥n de inmersi√≥n modular propuesta en [6] sobre el c√°lculo
de procesos basado en Reo, propuesto en este trabajo y el c√°lculo de procesos basado en Linda,
propuesto en [2],
El resto del trabajo se organiza de la siguiente forma. En la secci√≥n 2 se presenta el modelo de
interacci√≥n. En la secci√≥n 3 mostramos el estudio de la potencia expresiva del modelo. Finalmente
indicamos algunas conclusiones y trabajos futuros.
2. Modelo de Interacci√≥n basado en conectores
En el contexto de los lenguajes y modelos de coordinaci√≥n, nos interesa analizar el modelo
basado en la composici√≥n de canales de comunicaci√≥n, introducido por Arbab et. al [4], en el cual
el ‚Äùentorno‚Äùprogresa teniendo en cuenta las acciones de entrada y salida que se realizar√°n sobre los
canales que est√°n involucrados en la conexi√≥n entre componentes coordinadas. En este contexto
cada conector impone un patr√≥n de comunicaci√≥n entre las entidades que conecta.
Reo es un modelo de coordinaci√≥n que permite la construcci√≥n de sistemas por la composici√≥n
de componentes que interaccionan y cooperan a trav√©s de conectores. Los conectores se construyen
a partir de un conjunto de canales, s√≠ncronos y as√≠ncronos, con comportamiento bien definido y el
operador merge. Los extremos de un conector son representados por secuencias de datos temporizadas (SDT) „ÄàŒ±, a„Äâ que dan su comportamiento potencial, cuyos cambios se reflejan por medio
de su derivativa „ÄàŒ±‚Ä≤, a‚Ä≤„Äâ. La comunicaci√≥n entre instancias de componentes se logra exclusivamente
por la aplicaci√≥n de operaciones de entrada y salida sobre los puntos de conexi√≥n, afectando directamente a los SDT‚Äôs que los representan. De forma general, c(k) = „ÄàŒ±(k), a(k)„Äâ identifica un
extremo en el que se han aplicado con √©xito k operaciones y sobre el cual una nueva operaci√≥n
exitosa producir√° un cambio de c(k) a c(k+1)[5].
2.1. El lenguage R
Proponemos un √°lgebra de procesos R basado en las primitivas de comunicaci√≥n de Reo .
Los agentes en R se construyen a partir de los operadores prefijo, elecci√≥n no determinista y
2
composici√≥n paralela. A continuaci√≥n definimos formalmente la sintaxis de R:
P ::= 0 | A.P | P + P | P ‚Äñ P | recX.P
A ::= wr(c, v) | tk(c, v) | rd(c, v)
d√≥nde 0 denota el proceso vac√≠o, y c un extremo de entrada o salida de un conector. Los prefijos
wr, tk y rd son las abreviaciones de las operaciones write, take y read respectivamente.
Como en Reo la comunicaci√≥n es posible s√≥lo en presencia de un conector, en la definici√≥n de la
sem√°ntica operacional del c√°lculo, la sem√°ntica del conector es una pieza esencial. Consideramos
el comportamiento de un conector C dado por un conjunto de transiciones que tienen la forma
„ÄàC, act„Äâ
act17‚àí‚ÜíC „ÄàC
‚Ä≤, act2„Äâ
d√≥nde act denota el conjunto de acciones que aplicadas en paralelo sobre los extremos del conector pueden producir un progreso sobre el mismo, dando un nuevo estado representado por C‚Ä≤.
El conjunto act1 denota las acciones cuya aplicaci√≥n tiene √©xito inmediato, y act2 representa el
subconjunto de acciones que han quedado suspendidas en alg√∫n extremo del conector. Un ejemplo de un conector simple en Reo es LR = {ci, co}, las transiciones (1), (2) y (3) describen su
comportamiento.
„Äà{ci, co}, {wr(ci, d)}„Äâ
{wr(ci,d)}7‚àí‚ÜíC „Äà{ci
‚Ä≤, co}, ‚àÖ„Äâ (1)
„Äà{ci
k, co
j}, {tk(co, d)}„Äâ
{tk(co,d)}
7‚àí‚ÜíC „Äà{ci
k, co
j+1}, ‚àÖ„Äâ (k > j) (2)
„Äà{ci
k, co
j}, {rd(co, d)}„Äâ
{rd(co,d)}
7‚àí‚ÜíC „Äà{ci
k, co
j}, ‚àÖ„Äâ (k > j) (3)
El sistema de transiciones del cuadro 1 describe el modelo computacional de R. En cualquier
caso el agente s√≥lo podr√° proceder en presencia de un conector que contenga en su comportamiento
transiciones etiquetadas con el mismo conjunto de acciones que se est√° intentando aplicar.
3. Potencia expresiva del modelo
Para analizar la potencia expresiva del lenguaje R, en primera instancia lo comparamos con
el lenguaje L propuesto en [] para el modelo de coordinaci√≥n Linda. El criterio adoptado para la
comparaci√≥n de ambos modelos se basa en la noci√≥n de inmersi√≥n modular [], o sea una traducci√≥n
composicional que preserva algunos aspectos de observables, en particular √©xito y fracaso. Sean dos
lenguajes L y L‚Ä≤, y las funciones (observables) O : L ‚Üí ObsL y O‚Ä≤ : L‚Ä≤ ‚Üí ObsL‚Ä≤ , definidas sobre
sus sem√°nticas, tal que ObsL y ObsL‚Ä≤ son algunos de los posibles dominios. Entonces, decimos
que L es m√°s expresivo que L‚Ä≤ (o que L‚Ä≤ puede ser embebido por L), si existe un mapping C
(compilador) de los estados de L‚Ä≤ a los estados de L (C : L‚Ä≤ ‚Üí L) y un mapping D (decodificador)
de ObsL a ObsL‚Ä≤ tal que para todo estado AL‚Ä≤ : D(O(C(A))) = O‚Ä≤(A).
L‚Ä≤
O‚Ä≤ //
C

ObsL‚Ä≤
L
O // ObsL
D
OO
3
(1)R „Äàact ¬∑ P,C„Äâ
act
‚àí‚Üí „ÄàP,C„Äâ
(2)R
„ÄàP1,C„Äâ
act
‚àí‚Üí „ÄàP ‚Ä≤1,C„Äâ
„ÄàP1 + P2,C„Äâ
act
‚àí‚Üí „ÄàP ‚Ä≤1,C„Äâ
(3)R
„ÄàP1,C„Äâ
act
‚àí‚Üí „ÄàP ‚Ä≤1,C„Äâ
„ÄàP1 ‚Äñ P2,C„Äâ
act
‚àí‚Üí „ÄàP ‚Ä≤1 ‚Äñ P2,C„Äâ
(4)R
„ÄàP1,C„Äâ
act1‚àí‚Üí „ÄàP ‚Ä≤1,C„Äâ „ÄàP2,C„Äâ
act2‚àí‚Üí „ÄàP ‚Ä≤2,C„Äâ
„ÄàP1 ‚Äñ P2,C„Äâ
act1
‚äé
act2‚àí‚Üí „ÄàP ‚Ä≤1 ‚Äñ P
‚Ä≤
2,C„Äâ
(5)R
„ÄàP,C„Äâ
act
‚àí‚Üí „ÄàP ‚Ä≤,C„Äâ „ÄàC, act„Äâ
act
7‚àí‚ÜíC
‚àó
„ÄàC‚Ä≤, ‚àÖ„Äâ
„ÄàP,C„Äâ ‚àí‚Üí „ÄàP ‚Ä≤,C‚Ä≤„Äâ
(6)R
„ÄàP1,C„Äâ
act1‚àí‚Üí „ÄàP ‚Ä≤1,C„Äâ „ÄàP2,C„Äâ
act2‚àí‚Üí „ÄàP ‚Ä≤2,C„Äâ „ÄàC, act„Äâ
act17‚àí‚ÜíC
‚àó
„ÄàC‚Ä≤, act2„Äâ
„ÄàP1 ‚Äñ P2,C„Äâ ‚àí‚Üí „ÄàP ‚Ä≤1 ‚Äñ P2,C
‚Ä≤„Äâ
Cuadro 1: Sistema de transiciones para el c√°lculo R
De Boer y Palamidessi propusieron en [6] tres nuevas restricciones sobre el codificador C y
el decodificador D, para obtener una definici√≥n de inmersi√≥n modular adecuada para comparar
lenguajes
Definici√≥n 1 Los observables en R son dados por la funci√≥n OR : R ‚Üí ObsR definida por :
ss ‚àà OR(P,C) if„ÄàP,C„Äâ ‚Üí
‚àó „Äà0R,C
‚Ä≤„Äâ
ff ‚àà OR(P,C) if‚àÉQ 6= 0R.„ÄàP,C„Äâ ‚Üí
‚àó „ÄàQ,C‚Ä≤„Äâ 6‚Üí
Comparamos la potencia expresiva de L y R en presencia de un conector LR como el introducido en la secci√≥n previa. El compilador que consideramos es el siguiente:
Definici√≥n 2 (Compilador) Definimos el compilador C : L ‚àí‚Üí R por:
C(in(t).P ) =def tk(co, t).C(P )
C(out(t).P ) =def wr(ci, t).C(P )
C(rd(t).P ) =def rd(ci, t).C(P )
C(P1 +L P2) =
def C(P1) +R C(P2)
C(P1 ‚ÄñL P2) =
def C(P1) ‚ÄñR C(P2)
C(0L) =
def C(0R)
Proposici√≥n 3 () Dados 2 procesos P, P ‚Ä≤ ‚àà L,
4
1. Si P ‚ÄñL St
Œ±
‚àí‚Üí P ‚Ä≤ ‚ÄñL St‚Ä≤ (Œ± 6= t) entonces „ÄàC(P ), LRSt„Äâ
Œ±R‚àí‚Üí „ÄàC(P ‚Ä≤), LRSt‚Ä≤„Äâ, d√≥nde
Œ±R =
Ô£±
Ô£≤
Ô£≥
œÑ if Œ± = œÑ
tk(co, t) if Œ± = t
rd(co, t) if Œ± = t
2. Si P ‚ÄñL St
t
‚àí‚Üí P ‚Ä≤ ‚ÄñL St‚Ä≤ entonces ‚àÉ j > 0 d√≥nde LRoSt = c
j
o y LR
o
St‚Ä≤ = c
j+1
o .
Prueba: La prueba es por inducci√≥n estructural sobre la complejidad de las reglas en el lenguage
L.
El resultado previo nos muestra la relaci√≥n entre los sistemas de transici√≥n de ambos c√°lculos.
Esta relaci√≥n emerge debido a que el comportamiento del conector tipo bag en Reo permite simular
las acciones de Linda sobre el espacio de tuplas.
Considerando la definici√≥n del compilador C, la noci√≥n de observables y el decodificador D que
fue definido como la identidad se puede probar el teorema siguiente:
Teorema 4 El compilador C es una inmersi√≥n modular
Prueba:
Las propiedades enunciadas en [] se satisfacen considerando la noci√≥n de observables, el hecho
de que D es la identidad y la definici√≥n del compilador. Para probar O(C(A))) = O‚Ä≤(A) se procede
probando la doble inclusi√≥n, considerando los elementos posibles de los conjuntos de observables.
Es posible definir una inmersi√≥n modular en el sentido opuesto, considerando el mismo conector. Ambas inmersiones nos abilitan a afirmar que ambos modelos (basados en Linda y Reo) son
igualmente expresivos al considerar el caso as√≠ncrono y un conector de tipo bag.
4. Conclusions
Los trabajos realizados sobre lenguajes y modelos de coordinaci√≥n tienen como objetivo principal la interoperabilidad de aplicaciones software, normalmente descritas en lenguajes de programaci√≥n distintos. El modelo de interacci√≥n presentado permite ampliar la informaci√≥n que
proporcionan las interfaces de componentes con el fin de evitar multitud de problemas, como los
que surgen a nivel de protocolos, y as√≠ asegurar que el comportamiento cooperativo ser√° el esperado. La noci√≥n de canales m√≥viles nos permite establecer comunicaciones entre componentes
y habilita reconfiguraciones din√°micas de conecciones en un sistema. Esto refuerza la reusabilidad de sistemas en los que es posible reemplazar una componente por otra versi√≥n sin tener que
cambiar otras componentes en el sistema. Reo posee una gran potencia expresiva de por si. Sin
embargo hemos comparado la expresividad de ambos modelos de descripci√≥n de sistemas concurrentes, y entre las diversas herramientas disponibles utilizamos la inmersi√≥n modular estudiando
el caso as√≠ncrono, en el que el conector empleado en el modelo Reo presenta un comportamiento
equivalente a un canal de tipo bag. Como consecuencia del estudio, observamos que, para este
caso concreto, ambos modelos son igualmente expresivos. Aunque el resultado principal obtenido
era previsible, dado que el conector considerado en Reo se comporta de forma similar a como lo
hace el espacio de tuplas compartido de Linda, este trabajo constituye un punto de partida para
5
analizar la expresividad entre las dos alternativas m√°s influyentes en el contexto de los modelos
de coordinaci√≥n. Como conclusi√≥n de este trabajo hemos de resaltar la viabilidad del enfoque
seguido para realizar la comparaci√≥n mencionada, que nos permitir√° analizar la expresividad de
otros conectores de Reo frente a primitivas adicionales de Linda. Dicho enfoque se basa en (1)
homogeneizar ambos modelos a trav√©s de la definici√≥n de respectivos c√°lculos de procesos y (2) el
uso de la noci√≥n de inmersi√≥n modular.
En particular, se demuestra que ambos modelos son igualmente expresivos para un tipo concreto de conector as√≠ncrono. Sin embargo el enfoque utilizado y la homogeneizac√≥n de las dos
familias de lenguages bajo c√°lculos similares permitir√° realizar una comparaci√≥n exhaustiva de
ambos modelos de coordinaci√≥n.
Nuestro trabajo futuro estar√° destinado a estudiar profundamente mas conectores de Reo
y definir un lenguaje de descripci√≥n de interacciones basado en Reo para la coordinaci√≥n de
componentes al estilo de lo realizado en el contexto de Linda. A partir del an√°lisis exahustivo de
la expresividad de los dos modelos descritos, nuestra intenci√≥n es explorar si uno es m√°s adecuado
que el otro en determinadas circunstancias para expresar la interacci√≥n entre componentes. No
descartamos la posibilidad de que partes de un sistema puedan ser convenientemente descritos con
un formalismo, mientras que otras sean m√°s susceptibles de ser especificadas con el otro modelo.
