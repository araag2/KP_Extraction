Estrategias de reparación para sitios web incompletos
﻿ El desarrollo y mantenimiento de sitios Web no es un tarea fácil. Garantizar que la información
de un sitio Web es consistente resulta cada vez más dificil, por ello los administradores Web necesitan de
mecanismos que ayuden a reparar estas inconsistencias. En este trabajo, completamos la metodología de
reparación semiautomática de sitios Web erróneos presentada en un trabajo anterior con el tratamiento
de los errores de completitud. Comenzamos con la categorización de dichos errores mediante dos nuevos
órdenes que definimos sobre el conjunto de errores de completitud obtenidos en el proceso de verificación.
Utilizando estos órdenes, definimos sendas estrategias capaces de minimizar la cantidad de acciones de
reparación a realizarse para generar un sitio Web completo con respecto a su especificación.
Keywords: Verificación y reparación de sitios Web, reescritura, simulación, reescritura parcial,
estrategias de reparación.
1 Introducción
Los sistemas software para la web se han convertido en un instrumento insustituible de la
moderna sociedad de la información: hacen posible el intercambio de información de forma
rápida y a escala global; constituyen el medio natural de las grandes transacciones financieras;
permiten acceder de forma rápida y selectiva a grandes volúmenes de información especializada,
etc. Todo esto ha incrementado la complejidad de los sitios web y puesto de manifiesto la
necesidad de asistir a los administradores de sistemas web en la detección y reparación de las
posibles incorrecciones o inconsistencias.
En este escenario, es esencial el desarrollo de métodos, modelos y herramientas que se
apliquen a la verificación formal de sistemas y servicios web, y que permitan no sólo detectar
automáticamente posibles errores en los enlaces o en la estructura sino también en la semántica
de los mismos. Los fallos de calidad deben ser detectados con precisión para que, de esta
manera, se puedan aplicar estrategias de reparación (idealmente) automáticas que permitan
obtener sitios web que sean correctos y completos con respecto a una especificación o modelo
conceptual de los mismos.
? This work has been partially supported by the EU (FEDER) and Spanish MEC TIN-2004-7943-C04-02 project, the
Generalitat Valenciana under grant GV06/285, and Integrated Action Hispano-Alemana HA2006-0007. Daniel Romero
is also supported by ALFA grant LERNet AML/19.0902/97/0666/II-0472-FA. Pedro Ojeda is also supported by the
Generalitat Valenciana under FPI grant BFPI/2007/076.
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
377
En el marco de la reparación existen también diferentes líneas de investigación incipientes.
En [17], se presenta un marco para reparar inconsistencias en documentos distribuidos, como
un complemento a la herramienta de verificación xlinkit [11]. La principal contribución es la
semántica que pone en correspondencia el lenguaje lógico de primer orden de xlinkit a un
catálogo de acciones reparadoras que pueden ser usadas para corregir de forma interactiva las
violaciones de reglas, aunque este trabajo no predice si la ejecución de la acción puede provocar una nueva violación de dichas reglas. Tampoco es posible detectar si dos expresiones que
formulan un requerimiento para el sitio Web son incompatibles. Similarmente, en [18, 20] se
presenta una extensión para CDET [19]. Esta extensión incluye un mecanismo para eliminar
inconsistencias de un conjunto de documentos interrelacionados. Primero se genera un grafo
dirigido acíclico (DAG) que representa las relaciones entre documentos, y entonces se derivan
las reparaciones directamente de este grafo. En este caso, las reglas temporales soportan interferencias y la compatibilidad de las reparaciones sí es tenida en cuenta. Desafortunadamente,
esta compatibilidad resulta muy costosa de comprobar en reglas temporales. Ambas aproximaciones se basan en técnicas del campo de las bases de datos activas [8]. Otras investigaciones
recientes en este campo se centran en la derivación de reglas activas que, automáticamente, lancen acciones reparadoras que conducen a un estado consistente después de cada actualización
[16].
En trabajos previos [6, 2], presentamos un marco para la verificación automática de sitios
Web. Dicho marco permite especificar restricciones de integridad para un sitio Web y entonces comprobar automáticamente si estas restricciones se satisfacen. El marco proporciona
un lenguaje de especificación que permite definir propiedades sintácticas así como semánticas
de un sitio Web. Como resultado de la verificación se identifican dos tipos de errores: error de
corrección (correctness error) y error de completitud (completeness error).
Tomando como base el marco de verificación de [2], en [3] hemos formulado también una
metodología para la corrección del código erróneo. En ella, partiendo de una categorización de
los diferentes tipos de error que pueden encontrarse en un sitio Web respecto a su especificación
inicial, clasificamos las distintas clases de acciones de reparación que pueden ejecutarse para
corregir cada error dado.
Cómo complemento a este trabajo, en [7] realizamos un análisis sistemático sobre la relación
entre los errores de corrección detectados por nuestra metodología y, de esta manera, definimos
dos estrategias, una para minimizar el número de acciones de reparación a ser ejecutadas y la
otra para minimizar la información a ser cambiada o eliminada sobre el sitio Web. El resultado
de la fase de corrección es un sitio Web correcto w.r.t. a su especificación aunque no completo.
Nuestra contribución. En este trabajo, completamos nuestra metodología de reparación
[3, 6] para considerar y eliminar los errores de completitud. Empezamos analizando la relación
entre los errores de completitud e introducimos dos órdenes (¹inf y ¹sup) que se corresponden
con dos criterios diferentes de priorización u ordenación de los errores. Aprovechando este
análisis formalizamos dos operaciones de reparación: repairByDelete la cual se apoya en el orden
¹inf y repairByInsert la cual se apoya en el orden ¹sup. Con la utilización de estas operaciones,
definimos dos estrategias que reducen la cantidad de acciones necesarias para reparar un sitio
Web. Esto nos permite mejorar nuestro sistema de reparación, al tiempo que generar un sitio
que cumple totalmente sus especificaciones.
Estructura del trabajo. El resto del trabajo está estructurado como sigue. La sección 2
resume algunas definiciones y notaciones preliminares. En la sección 3, recordamos un método
simple de transformación de documentos XHTML/XML en términos de Herbrand, mostramos
la noción de simulación utilizada para reconocer patrones dentro de un sitio Web y presentamos
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
378
el lenguaje de especificación de sitios Web. En la sección 4 formalizamos los errores de completitud que pueden ser detectados tras el proceso de verificación y presentamos dos operaciones
que permiten su reparación. La sección 5 proporciona un análisis de la dependencia entre los
errores de completitud, mientras en la sección 6 desarrollamos las estrategias de reparación de
un sitio Web incompleto al tiempo que demostramos que la reparación no introduce nuevos
errores. La sección 7 presenta las conclusiones del trabajo.
2 Preliminares
Decimos que un conjunto finito de símbolos es un alfabeto. Dado el alfabeto A, A∗ denota
el conjunto de todas las secuencias finitas de elementos sobre A. La igualdad sintáctica entre
objetos se representa como ≡.
Denotamos por V un conjunto infinito de variables y Σ denota un conjunto de símbolos de
función, o signatura. Consideramos las signaturas de aridad variable como en [12] (i.e., signaturas en las cuales los símbolos tienen aridad no especificada, es decir, pueden tener cualquier
número de argumentos a continuación). τ(Σ,V) y τ(Σ) denotan el álgebra de términos con
variables y el álgebra de términos básicos construidas en Σ ∪ V y Σ, respectivamente. Los
términos se consideran árboles etiquetados de la manera usual.
Las posiciones son representadas por secuencias de números naturales que denotan el camino
de acceso a un término. La secuencia vacía Λ denota la posición raíz. Con la notación w1.w2, se
denota la concatenación de la posición w1 y la posición w2. Las posiciones son ordenadas por
el orden de prefijos, que es, dada las posiciones w1, w2, w1 ≤ w2 si existe una posición x s.t.
w1.x = w2.
Dado S ⊆ Σ ∪ V , OS(t) denota el conjunto de posiciones de un término t que tenga como
raíz al símbolo S. Por otra parte, para una posición x, {x}.OS(t) = {x.w | w ∈ OS(t)}.
Con t|v representamos el subtérmino cuya raíz es v de t. t[r]v es el término t con el subtérmino
cuya raíz es v sustituido por el término r.
Una sustitución σ ≡ {X1/t1, X2/t2, . . .} es una aplicación del conjunto de variables V en
el conjunto de términos τ(Σ,V) que satisface las siguientes condiciones: (i)Xi 6= Xj, si i 6= j,
(ii)Xiσ = ti, i = 1, ..n, y (iii)Xσ = X, para X ∈ V \ {X1, ..., Xn}. Con ε representamos
una sustitutión vacía. Dada una sustitución σ, el dominio de σ es el conjunto Dom(σ) =
{X|Xσ 6≡ X}. Dadas las sustituciones σ1 y σ2, tal que Dom(σ1) ⊆ Dom(σ2), por σ1/σ2,
definimos la sustitución {X/t ∈ σ1|X ∈ Dom(σ1) \ Dom(σ2)} ∪ {X/t ∈ σ2|X ∈ Dom(σ1) ∩
Dom(σ2)} ∪ {X/X|X 6∈ Dom(σ1)}. Una instancia de un término t se define como tσ, donde
σ es una sustitución. Con Var(s) representamos el conjunto de variables que aparecen en el
objeto sintáctico s.
Los sistemas de rescritura de términos proporcionan un modelo computacional adecuado
para los lenguajes funcionales. En consecuencia, seguimos un marco estándar de rescritura de
términos para formalizar nuestra propuesta (ver [5, 14]).
Un sistema de rescritura de términos (TRS para abreviar) es un par (Σ,R), donde Σ es
una signatura y R es un conjunto finito de reglas de reducciones (o rescrituras) de la forma
λ → ρ, λ, ρ ∈ τ(Σ,V), λ 6∈ V and V ar(ρ) ⊆ V ar(λ). A menudo escribimos R en vez de (Σ,R).
Un paso de rescritura es la aplicación de una regla de rescritura a una expresión. Un término
s se rescribe a un término t via r ∈ R, s →r t (or s →R t), si existe una posición u ∈ OΣ(s),
r ≡ λ → ρ, y una sustitución σ tal que s|u ≡ λσ y t ≡ s[ρσ]u. Cuando no haya riesgo de
confusión, omitiremos cualquier subíndice (por ejemplo s → t). Un término s está en una
forma irreducible (o forma normal) w.r.t. R si no existe un término t s.t. s →R t. Un t es la
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
379
forma irreducible de s w.r.t. R (en símbolos s →!R t) si s →∗R t y t es irreducible. Decimos que
un TRS R es terminante, si no existe una secuencia infinita t1 →R t2 →R .... Un TRS R es
confluente si, para todos los términos s, t1, t2, tal que s →∗R t1 y s →∗R t2, existe un término t
s.t. t1 →∗R t y t2 →∗R t. Cuando R es terminante y confluente, se denomina canónico. En un
TRS canónico, cada término de entrada t puede ser reducido a una única forma irreducible.
3 Denotación de sitios Web
Sean dos alfabetos T y Tag . Representaremos el conjunto T ∗ por Text . Llamaremos a un
objeto t ∈ Tag elemento tag, y a un objeto w ∈ Text elemento text. Las páginas Web se
proporcionan con una estructura de árbol; de esta manera, pueden ser traducidas de forma
directa a términos ordinarios de un álgebra de términos τ(Text ∪ Tag) dada [2]. Note que los
atributos tag XML/XHTML pueden considerarse elementos etiquetados comunes y, por tanto,
traducidos de la misma forma que éstos. De esta manera, un sitio Web puede ser representado
como un conjunto finito de términos ground {p1...pn}.
En lo siguiente, también consideraremos los términos del álgebra de términos no-ground
τ(Text ∪ Tag ,V), los cuales pueden contener variables. Un elemento s ∈ τ(Text ∪ Tag ,V) es
llamado “plantilla de página Web” (Web page template).
En nuestra metodología usamos las plantillas de páginas Web para especificar patrones de
páginas Web incompletas o ausentes en el sitio Web. Para mecanizar la detección de estos
patrones dentro de un sitio Web, empleamos un mecanismo de simulación de árboles, que
pasamos a describir en la siguiente sección. En las Figuras 1(a) y 1(b), se ve un ejemplo de
transformación de una página Web a un elemento del álgebra de términos.
<book> book(
<title>El Alquimista</title> title(El Alquimista),
<author>Coelho</author> author(Coelho), book(code(X),author(Y))
<year>2002</year> year(2002),
<code>PC02</code> code(PC02)
</book> )
(a) (b) (c)
Fig. 1. Ejemplo de transformación de una página Web a un elemento del álgebra de términos, y una plantilla de página
Web.
3.1 Simulación
La noción de simulación nos permite analizar y extraer la estructura parcial de una página
Web sujeta a verificación. Las simulaciones se han utilizado en varios trabajos relacionados
con la consulta, transformación y verificación de datos semiestructurados (ej. [1, 10, 13]). Para
simplificar nuestra exposición, no consideramos la semántica de las etiquetas; esto requeriría
introducir ontologías, lo cual queda fuera del alcance de este trabajo.
La noción de simulación, E, es una adaptación de la relación de embedding de Kruskal [9],
ignonardo la regla de diving4 [15].
4 La regla de diving permite “saltar” parte del término del lado derecho de la relación E. Formalmente, s E f(t1, . . . tn),
si s E ti, para algún i.
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
380
Definition 1 (simulación).
La relación de simulación E⊆ τ(Text ∪ Tag)× τ(Text ∪ Tag) sobre páginas Web se define
como sigue:
f(t1, . . . , tm) E g(s1, . . . , sn) sii f ≡ g y
ti E spi(i), para i = 1, . . . , m, y
alguna función inyectiva
pi : {1, . . . , m} → {1, . . . , n}.
Dadas dos páginas Web s1 y s2, si s1 E s2 se dice que s1 simula (o es embebida o reconocida
dentro de) s2. También se dice que s2 embebe s1. Note que, en la Definición 1, para el caso
donde m es 0 se tiene c E c para cada símbolo constante c. Note también que s1 6E s2 si s1 o s2
contiene variables.
Un ejemplo de simulación se observa en la Figura 1: la plantilla de página Web de la Figura
1(c) puede ser reconocida dentro de la estructura del (fragmento de) página Web de la Figura
1(b).
3.2 Lenguaje de especificación
En esta sección, describiremos brevemente el lenguaje de especificación Web dado en [2]. Una
especificación Web es una tripla (IN , IM , R), donde IN e IM son conjuntos finitos de reglas de
corrección (correctness rule) y reglas de completitud (completeness rule), y R un conjunto de
funciones auxiliares.
El conjunto IN describe restricciones para detectar páginas Web erroneas (correctNess rules).
Un análisis de optimización sobre los errores de corrección detectados se presentó en [7], y está
fuera del alcance de este trabajo.
El tercer conjunto de reglas IM especifica propiedades para detectar páginas Web incompletas/ausentes (coMpleteness rules). Una regla de completitud está definida como l ⇀ r 〈q〉,
donde l y r son términos y q ∈ {E, A}. Las reglas de completitud de una especifiación Web
formalizan el requerimiento de que alguna información deba estar incluida en todas o algunas
de las páginas del sitio Web. Los atributos 〈A〉 y 〈E〉 se usan para distinguir, respectivamente,
reglas universales (universal rule) de las existenciales (existential rule), como explicamos mas
adelante. La parte derecha de las reglas de completitud r puede contener funciones, las cuales
están definidas en R y, algunos símbolos, pueden estar marcados por medio del símbolo ]. La
información marcada en r se usa para seleccionar el subconjunto del sitio Web sobre el cual se
verificará la condición formalizada por r.
Intuitivamente, la interpretación de una regla de completitud universal (resp. una regla
de completitud existencial) w.r.t. un sitio Web W es la siguiente: si (una instancia de) l es
“reconocida” en W , (una instancia de) la forma irreducible de r debe también ser “reconocida” en todas (resp. algunas de) las páginas Web que embeban (una instancia de) la estructura marcada de r. Una operación auxiliar mark es utilizada para obtener el subconjunto de
páginas Web de W que se ajustan a la estructura de un término marcado r, por ejemplo,
mark(]f(h(X)), {p1, p2}) = {p1}, donde p1 = f(m(a)) y p2 = h(g(b)).
3.3 Reescritura parcial
La reescritura parcial [2] nos permite extraer de una página Web s, usando una regla l ⇀ r,
una parte (subtérmino) de s que es simulada por alguna instancia ground de l, replazando
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
381
s por una instancia ground de r. Mas formalmente, sea s, t ∈ τ(Text ∪ Tag ,V). Entonces, s
reescribe parcialmente a t por medio de la regla l ⇀ r y la sustitución σ sii existe una posisición
u ∈ OTag(s) s.t. (i) lσ E s|u, y (ii) t = Reduce(rσ,R), donde la función Reduce(x ,R) computa
por reescritura de términos estándar la forma irreducible de x en R. Note que el contexto de la
expresión reducible seleccionada s|u es omitido después de cada paso de reescritura. Por s ⇀I t,
denotamos que s se reescribe parcialmente a t usando alguna regla que pertenece al conjunto
I.
4 Errores y acciones de reparación
El lenguaje de especificación Web, junto con la técnica de verificación y validación de propiedades
formales sobre sitios Web, permite detectar páginas Web incompletas o ausentes en un sitio
Web, obteniendo así un conjunto de errores que denominaremos “errores de completitud” (completeness error). Estos errores representan la información inconsistente o ausente en el sitio
Web.
Podemos distinguir tres tipos de errores de completitud: Missing page (o página ausente),
cuando una expresión no aparece en el sitio Web; Universal completenes error (o error universal), Existential completeness error (o error existencial). Un error universal (resp. existential)
corresponde a la satisfacción de una condición universal (resp. existential) del lenguaje de especificación.
Estos tres tipos de errores (M,A,E) pueden ser detectados por reescritura parcial sobre las
páginas Web y la especificación IM .
Más formalmente tenemos la siguiente definición.
Definition 2 (completeness error). Sea W un sitio Web, (IN , IM , R) una especificación
Web, y c ∈ {M,A,E}. Sea q ∈ {A,E}. Un error de completitud en W es la tupla e ≡ (s0 ⇀∗IM
sn−1 ⇀IM sn, P, c) que satisface:
i) Existe una sustitución σ s.t. rσ = sn para alguna l ⇀ r〈q〉 ∈ IM .
ii) Existe una sustitución σ′ s.t. l′σ′ = s0 para alguna l′ ⇀ r′〈q′〉 ∈ IM .
iii) Existe p ∈ W s.t. s0 E p .
iv) P = {p | p ∈ mark(r,W ) y sn 6E p} .
v) c = (M si P = ∅) o (q si P 6= ∅) .
En la definición 2, s0 ⇀∗IM ⇀ sn−1 ⇀IM sn representa la secuencia de pasos de reescritura
hasta detectar el término sn que no satisface la regla (por cuestión de simplicidad escribiremos
s0 ⇀ . . . ⇀ sn). Denotamos por P el conjunto de páginas Web incompletas, mientras que c es
la clase o tipo del error detectado (M missing page, A universal error, y E existential error).
Note que, para un error de tipo Missing Page el conjunto P es vacío.
Denotamos con EM(W ) (o simplemente EM), al conjunto de todos los errores de completitud
detectados en un sitio Web W . Cuando |EM(W )| = 0 decimos que W está libre de errores de
completitud o simplemente W está reparado.
Con el objetivo de reparar un sitio Web que contiene errores, en [3] definimos tres acciones
reparadoras básicas de corrección que permiten eliminar la inconsistencia y/o añadir la información ausente. Las acciones consideradas son las siguientes:
– delete(p, t) elimina todas las ocurrencias del término t en de la página Web p, y devuelve
la página Web modificada.
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
382
– insert(p, w, t) modifica la página Web p añadiendo el término t en p|w.
– add(p,W ) añade la página Web p al sitio Web W .
Note que las acciones reparadoras add e insert introducen nueva información en el sitio Web
que puede contener/provocar nuevos errores. Por ello, es importante restringir la información
que se puede añadir. Del mismo modo, la ejecución de la acción delete puede inducir nuevos
errores de completitud. Para prevenir estas situaciones, en [3] formalizamos las propiedades
safe y acceptable que garantizan el comportamiento seguro de estas acciones.
A groso modo, estas propiedades nos aseguran, respectivamente, que no se introducen nuevos
errores, y que la cantidad de errores en el sitio Web decrece tras la ejecución de cada acción
reparadora. Estas propiedades garantizan la terminación del proceso de corrección.
A lo largo de este trabajo, asuminos que la aplicación de las acciones reparadoras es siempre
acceptable. Un sitio Web está reparado si EM = φ.
4.1 Reparando errores de completitud
En esta sección se formulan las operaciones para reparar un sitio Web que contenga errores de
completitud. Sin pérdida de generalidad, se asume que el sitio Web W es incompleto pero correcto w.r.t. una especificación Web (IN , IM , R). Esto se justifica por la posibilidad de asumir el
haber ejecutado previamente la metodología de reparación de la corrección de [3]. Tal suposición
permite diseñar una metodología reparadora la cual “completa” el sitio Web sin introducir información incorrecta. Como dijimos en la sección anterior, cualquier error e ∈ EM(W ) puede
ser reparado añadiendo la información ausente o eliminando el dato que lo produjo. De igual
forma, consideramos acceptable a cualquier acción que se ejecute, lo cual se puede comprobar
fácilmente ejecutando la metodología de verificación de [2].
A continuación describimos cómo es posible reparar los errores de completitud detectados en
un sitio Web. En primer lugar, veremos cómo añadir la información necesaria; a continuación,
describiremos cómo eliminar la información incompleta que provocó el error.
4.2 Añadiendo información
Dependiendo del tipo de error de completitud, tenemos dos posibles acciones reparadoras a ser
ejecutadas, add(p,W ) e insert(p, w, t). La acción add se usa cuando tenemos un missing page
error mientras la acción insert se ejecuta cuando el error de completitud es universal error o
existential error. A continuación, analizaremos como reparar cada uno de ellos.
Missing Page error. Sea e ≡ (s0 ⇀ . . . ⇀ sn, P, q) un missing page error, donde P = W y
q = M . Para reparar e añadiemos al sitio Web W una página Web p que embeba la expresión
sn. De esta manera tenemos
W = W ∪ {add(p,W )}, donde sn E p|w para algún w ∈ OTag(p).
Existential error.. Sea e ≡ (s0 ⇀ . . . ⇀ sn, P, q) un existential error, donde q ≡ E.
Reparamos el error insertando el término sn en una página arbitraria p tal que p ∈ P . De
esta manera tenemos
W = W \ {p} ∪ {insert(p, w, sn)}, donde sn E p para algún w ∈ OTag(p).
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
383
Universal error Sea e ≡ (s0 ⇀ . . . ⇀ sn, P, q) un universal error, donde q ≡ A. Reparamos
el error insertando el término sn en cada página Web p ∈ P . De esta manera, el sitio Web W
se transforma como sigue
W = W \ {p} ∪ {insert(p, w, sn)} ∀p ∈ P , y ∃w ∈ OTag(p)
Note que la información añadida para reparar un error podría casualmente ser la misma
que sirva para reparar otro error. Postponemos a la Sección 5 el análisis de la posible relación
entre los errores.
4.3 Eliminando información incompleta
En algunas situaciones es más conveniente eliminar la información incompleta; en particular,
esta opción puede ser muy usada cuando se tiene información desactualizada. La principal idea
es eliminar aquella información del sitio Web que causa el error de completitud sin necesidad
de remplazar la nueva por información que satisfaga las especificaciones. El tratamiento de la
información incompleta es independiente del tipo de error (M,A,E) que estemos analizando;
por lo tanto, la información ausente se computa de la misma manera para los tres tipos de
errores.
A continuación, damos la definición de la operación repairByDelete.
Definition 3 (repairByDelete). Dado un sitio Web W y un error de completitud e ≡ (s0 ⇀
. . . ⇀ sn, P, q), el sitio Web W se transforma aplicando acciones de borrado de la siguiente
manera.
repairByDelete(e,W ) = {p ∈ W | s0 6E p|w,∀ w ∈ OTag(p)} ∪
{delete(p, s0) | p ∈ W, s0 E p|w, w ∈ OTag(p)}
En otras palabras, en la Definición 3 se elimina de todas las páginas Web la ocurrencia del
término s0 que inicia la secuencia de reescritura. Note que, si en la secuencia de reescritura de
dos errores tenemos el mismo término inicial, es posible que la reparación de un error corrija
de manera automática a otro.
5 Dependencia entre errores de completitud
Un sitio Web puede contener varios errores de completitud que podrían estar de alguna manera
conectados. Por otro lado, con la ejecución de una operación reparadora es posible reparar más
de un error. A continuación, analizamos cómo es la dependencia entre errores de completitud.
En primer lugar definimos dos órdenes parciales sobre el conjunto de errores EM , que están
inducidos por los términos de la secuencia de reescritura parcial que llevan a la manifestación
del error.
Definition 4. (orden inducido por los inferiores) Sean e1 ≡ (s0 ⇀ . . . ⇀ sn, P1, q1) y e2 ≡
(t0 ⇀ . . . ⇀ tm, P2, q2) dos errores de completitud en EM(W ). Entonces,
e1 ¹inf e2 sii s0 E t0.
Diremos que un error e ∈ EM(W ) es minimal w.r.t. ¹inf , sii no existe e′ s.t. e′ ¹inf e y e′ 6≡ e.
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
384
Definition 5. (orden inducido por los superiores) Sean e1 ≡ (s0 ⇀ . . . ⇀ sn, P1, q1) y e2 ≡
(t0 ⇀ . . . ⇀ tm, P2, q2) dos errores de completitud en EM(W ). Entonces,
e1 ¹sup e2 sii sn E tm.
En la Definición 4 se comparan los errores observando la relación de simulación que existe
entre los términos que iniciaron la secuencia de reescritura de cada error. En la Definición
5, se observan en cambio los términos finales de esta secuencia. Decimos que e1 y e2 no son
comparables w.r.t. ¹inf (resp. ¹sup) sii e1 6¹inf e2 (resp. e1 6¹sup e2) y e2 6¹inf e1 (resp.
e2 6¹sup e1).
Explotando estas dos definiciones sobre los errores obtenemos la siguiente proposición, que
establece que reparar el menor de los errores (e1) w.r.t. la relación ¹inf , utilizando la operación
repairByDelete, permite reparar de manera automática el resto de los errores que están relacionados con e1 según el órden ¹inf .
Proposition 1. Sea W un sitio Web, y ei ∈ EM(W ), i = 1 . . . m, y sea e1 ¹inf . . . ¹inf em.
Entonces, realizando la acción reparadora repairByDelete(e1,W ) se reparan todos los errores
e1, . . . , em en W .
Proof. Si se cumple la relación e1 ¹inf . . . ¹inf em, por la Definición 4 tenemos s10 E s20 E
. . . E sm0 . Por tanto, al ejecutar repairByDelete(e1,W ) se elimina el término s10 de W (por la
relación E, también se elimina un subtérmino de s20 y así sucesivamente hasta sm0). Junto con
ellos se eliminan también los respectivos errores. Note que esta proposición es independiente
del tipo que sean los errores (Missing page, Universal, o Existential error).
Veamos ahora cómo reparar el sitio Web añadiendo la información ausente y siendo e1 ¹sup
e2. ¿Es posible en esta situación reparar de manera automática más de un error?. A continuación, profundizaremos el análisis sobre la relación entre errores de completitud con el objetivo
de responder a esta pregunta.
En primer lugar, veremos algunas consideraciones necesarias:
– El orden de errores de completitud ¹sup permite conocer cuál es el error que, al ser reparado,
añadirá más información al sitio Web.
– El orden para tratar los errores debe ir de mayor a menor w.r.t. ¹sup; de esta manera,
cuando se repare un error se añade información útil para los errores menores.
– Si en (es el mayor error w.r.t. ¹sup) es un error de missing page y/o existencial, de manera
automática se reparan todos los errores de missing page y/o existenciales inferiores. Esto es
debido a que, de una sola vez, se añade información que embebe a la información ausente
indicada por los demás errores. Note que reparar un error universal actuará de la misma
manera sobre los errores missing page y/o existenciales inferiores.
– Cuando un error universal es reparado, es posible que páginas que pertenezcan a otro error
universal inferiror sean reparadas, y por lo dicho anteriormente, no pertenecen más al error.
– Una vez aplicada alguna acción reparadora en una página, no es necesario volver aplicarle
otra acción en un error inferior en el orden ¹sup.
Estas consideraciones, están expresadas en el Algoritmo 1, que describe el procedimiento
repairByInsert que permite reparar errores de completitud ordenados por la relación ¹sup.
Los resultados obtenidos en la Proposición 1 y el Algoritmo 1, permiten una optimización
obvia del marco de reparación, que formalizamos en las estrategias de reparación presentadas
a continuación.
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
385
Algorithm 1 Procedimiento para reparar errores de completitud ordenados por la relación
¹sup.
Require:
E = ei ∈ EM (W ), i = 1, . . . m, and [e1 ¹sup . . . ¹sup em]
Un sitio Web W
Ensure:
W | ∀e ∈ E, e 6∈ EM (W )
1: procedure repairByInsert (E, W )
2: PR = {} // conjunto de páginas reparadas
3: for i← m to 1 do
4: (s0 ⇀ . . . ⇀ sn, P, q)← ei
5: if q = M and PR = {} then
6: W ←W ∪ {add(sn, W )}
7: PR ← PR ∪ {sn}
8: else if q = E and PR = {} then
9: p← element(P ) // obtener una página
10: p′ ← insert(p, w, sn) // w es una posición arbitraria en p
11: W ←W \ {p} ∪ {p′}
12: PR ← PR ∪ {p}
13: else if q = A then
14: PAux ← P \ PR
15: for all p ∈ PAux do
16: p′ ← insert(p, w, sn) // w es una posición arbitraria en p
17: W ←W \ {p} ∪ {p′}
18: PR ← PR ∪ {p}
19: end for
20: end if
21: end for
22: end procedure
6 Estrategias de reparación
Cómo explicamos en la Sección 4, es posible reparar un error de completitud por la ejecución
de alguna acción reparadora. Por (e, a) denotamoa el par que contiene una acción reparadora
a que corrije el error e. Además, por la notación W ′ = a(e,W ) especificamos la ejecución de
la acción reparadora a sobre el sitio Web W , la cual retorna el sitio Web W ′ con el error e
reparado.
Llamaremos estrategia de reparación a la ejecución de una secuencia de acciones reparadoras
que permitan reparar todos los errores detectados en un sitio Web. Mas formalmente tenemos.
Definition 6 (estrategia de reparación). Sea W un sitio Web y sea EM(W ) = {e1, . . . , en}
el conjunto de errores de completitud en W . Una estrategia de reparación para W es la secuencia
[(e1, a1), . . . , (en, an)], donde a1, . . . , an son acciones reparadoras s.t.
(i) W0 = W ;
(ii) Wi = ai(ei,Wi−1) ∀i, 1 ≤ i ≤ n;
y entonces, EM(Wn) = ∅.
En la Sección 5 vimos cómo, al reparar un error de completitud, es posible reparar de manera
automática otro error. Este hecho nos sugiere que no es necesario ejecutar una acción reparadora
por cada error detectado en un sitio Web. A continuación, presentamos dos posibles estrategias
de reparación. En la primera, el objetivo es reducir la cantidad de información a eliminar para
obtener un sitio Web libre de errores; en la segunda, en cambio, se persigue reducir la cantidad
de información que se debe añadir. En ambos casos, sólo es necesario reparar un subconjunto
de los errores del sitio Web.
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
386
6.1 Estrategia reduce-delete-actions
La relación ¹inf define un orden parcial sobre el conjunto de errores de completitud EM . Por
otro lado, en la Proposición 1, vimos que reparar un error minimal w.r.t. ¹inf por medio de
la operación repairByDelete permite reparar los demás errores relacionados con él según este
orden. Es claro ver que si tenemos dos errores minimales e1 y e2 no comparables w.r.t. ¹inf es
necesario reparar ambos errores.
Definition 7 (estrategia reduce-delete-actions ). Sea W un sitio Web y sea EM(W ) el
conjunto de errores de completitud de W . Una estrategia de reparación (o RDA-strategy) que
permite reducir las acciones de eliminación para W es
[(e1, repairByDelete), . . . , (en, repairByDelete)],
donde ∀i, 1 ≤ i ≤ n, ei ∈ EM(W ) y es minimal w.r.t. ¹inf
La Definición 7 determina la estrategia RDA-strategy, la cual consiste en reparar todos
los errores minimales w.r.t. la relación ¹inf de un sitio Web. Esto nos lleva a la siguiente
proposición, que establece que la RDA-strategy permite obtener un sitio Web W libre de errores
reparando sólo un subconjunto de los errores de EM(W ).
Proposition 2. Sea W un sitio Web y sea EM(W ) el conjunto de errores de completitud de W .
Entonces, (i) la estrategia RDA-strategy obtiene un sitio Web libre de errores; (ii) la cantidad
de acciones reparadoras ejecutadas por la estrategia RDA-strategy es menor o igual al número
original de errores en EM .
Proof. Sea e ∈ EM(W ), dos situaciones son posibles: (i) si e es minimal w.r.t. ¹inf , e es
reparado con la operación repairByDelete; (ii) si e no es minimal w.r.t. ¹inf , entonces existe
un minimal e′ ∈ EM s.t. e′ ¹inf e que será reparado y, por la Proposición 1, e será reparado de
manera automática sin necesidad de ejecutar una acción reparadora para e.
6.2 Estrategia reduce-insertion-actions
El procedimiento repairByInsert (descrito en el Algoritmo 1), nos permite reducir la cantidad
de información que se debe añadir, como así también la cantidad de acciones reparadoras de
inserción a ser ejecutadas en un sitio Web.
Ahora observemos la siguiente situación, donde un error pertenece a más de un conjunto
de errores definidos por la relación ¹sup. Sean α = {ei}ni=1 y β = {e′j}mj=1 dos subconjuntos de
errores de EM(W ), tal que e1 ¹sup . . . ¹sup en y e′1 ¹sup . . . ¹sup e′m, y sea sea e un error de
completitud s.t. e ∈ α y e ∈ β. Es claro ver que un error puede pertenecer a más de un conjunto
de errores definidos por la relación ¹sup.
Llamaremos CEM a la secuencia de conjuntos de errores formados por la relación ¹sup como
sigue
CEM (EM ,¹sup) = [c1, . . . , cn]
s.t. (∀e ∈ EM , ∃i, 1 ≤ i ≤ n, s.t. e ∈ ci),
(∀i, 1 ≤ i ≤ n, ∀e1, e2 ∈ ci, e1 ¹sup e2 o e2 ¹sup e1) y
(∀i, 1 ≤ i ≤ n, |ci| > |ci+1|)
La secuencia CEM está ordenada por la cardinalidad de los conjuntos que la componen. Denotaremos por CEM (i) a la secuencia [c1, . . . , ci].
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
387
De esta manera, podemos definir una partición sobre el conjunto EM de la siguiente forma
Γ (EM) = {mi | mi = dif(CEM (i)), ∀i, 1 ≤ i ≤ k, k = |CEM |},
donde dif([x0]) = x0
dif([x0, . . . , xn]) = xn \ . . . \ x0, si n > 0
Definition 8 (estrategia reduce-insertion-actions). Sea W un sitio Web y sea EM(W ) el
conjunto de errores de completitud de W . Una estrategia para reducir la información a insertar
(o RIA-strategy) para W es
[(m1, repairByInsert), . . . , (mn, repairByInsert)],
donde ∀i, 1 ≤ i ≤ n, mi ∈ Γ (EM(W ))
La estrategia de la Definición 8 ejecuta el procedimiento repairByInsert en cada conjunto
de la partición de EM .
Proposition 3. Sea W un sitio Web y sea EM(W ) el conjunto de errores de completitud de
W y sea Γ (EM) una partición sobre EM . Entonces, (i) la estrategia RIA-strategy obtiene un
sitio Web libre de errores; (ii) la cantidad de acciones reparadoras ejecutadas por la estrategia
RIA-strategy es menor o igual al número original de errores en EM .
Proof. Los conjuntos de la partición Γ (EM) están ordenados w.r.t. ¹sup y, como vimos en el
Algoritmo 1, la ejecución del procedimiento repairByInsert reduce la cantidad de información
necesaria a añadir. De esta manera, con la ejecución de RIA-strategy reparamos todos los errores
de completitud del sitio Web.
A continuación se presenta un ejemplo para clarificar la utilización de las estrategias reducedelete-actions y reduce-insertion-actions.
Example 1. Sea el sitio Web W formado por el conjunto de páginas {p1, p2, p3, p4}; y la especificación Web (IN , IM , R) con IM = {r1, r2, r3, r4}, de la siguiente forma
Sitio Web W = {p1, p2, p3, p4} Especifcación Web (IM , IN , R)
p1 = m(s(b), f(a)) r1 = f(X) ⇀ ]g(X)〈A〉
p2 = m(m(g(a))) r2 = g(X) ⇀ ]h(X)〈E〉
p3 = m(l(b, a)) r3 = h(X) ⇀ ]p(X)〈A〉
p4 = h(b) r4 = l(X,Y ) ⇀ ]p(X,Y )〈A〉
El conjunto de errores de completitud EM detectados por el proceso de verificación es: EM
= {e1, e2, e3, e4, e5, e6}, en donde
e1 = ((g(a) ⇀ h(a)), {p4}, E) e4 = ((f(a) ⇀ g(a) ⇀ h(a)), {p4}, A)
e2 = ((h(b) ⇀ p(b)), {},M) e5 = ((g(a) ⇀ h(a) ⇀ p(a)), {},M)
e3 = ((l(b, a) ⇀ p(b, a)), {},M) e6 = ((f(a) ⇀ g(a) ⇀ h(a) ⇀ p(a)), {},M)
Note que e2, e3, e5 y e6 corresponden a errores de missing page, mientras que e1 es un error
existencial y e4 un error universal.
Los órdenes parciales ¹inf y ¹sup, de las Definiciones 4 y 5 respectivamente, establecen los
siguientes subconjuntos de errores
¹inf : {e1 ¹inf e5}; {e2}; {e3}; {e4 ¹inf e6}
¹sup : {e4 ¹sup e1}; {e2 ¹sup e3}; {e5 ¹sup e6 ¹sup e3}
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
388
A continuación describiremos cómo aplicar las estrategias reduce-delete-actions y reduceinsertion-actions definidas en las secciones 6.1 y 6.2 respectivamente.
Estrategia reduce-delete-actions. Se aplica la operación repairByDelete a cada error minimal w.r.t. ¹inf :
W ′ = repairByDelete(e4,
repairByDelete(e3,
repairByDelete(e2,
repairByDelete(e1,W ))))
donde W ′ = {p1, p2, p3}
p1 = m(s(b))
p2 = m(m( ))
p3 = m( )
−p4 fue eliminada−
Estrategia reduce-insertion-actions. Para aplicar esta estrategia se siguen tres pasos:
– Paso 1. Obtener la secuencia CEM (EM ,¹sup)
CEM = [c1, c2, c3] = [{e5, e6, e3}, {e2, e3}, {e4, e1}]
– Paso 2. Realizar la partición Γ (EM)
Γ (EM) = {m1,m2,m3}
donde m1 = c1 = {e5, e6, e3},
m2 = c2 \ c1 = {e2} y
m3 = c3 \ c2 \ c1 = {e4, e1}
– Paso 3. Aplicar el procedimiento repairByInsert (descrito en el Algoritmo 1) a cada conjunto m ∈ Γ (EM):
W ′ = repairByInsert(m3,
repairByInsert(m2,
repairByInsert(m1,W ))))
donde W ′ = {p1, p2, p3, p4, p5, p6}
p1 = m(s(b), f(a))
p2 = m(m(g(a)))
p3 = m(l(b, a))
p4 = h(b, a)
p5 = p(b, a)
p6 = p(b)
7 Conclusiones
Encontrarse con información incompleta o indeseada en la Web es muy frecuente, por eso la
administración y mantenimiento de la Web es un problema abierto y urgente. En este trabajo,
completamos la metodología de reparación semiautomática de sitios Web erróneos presentada
en [3] con el tratamiento y eliminación de los errores de completitud. Para ello, establecemos
dos relaciones de órden parcial (¹inf y ¹sup) sobre los errores de completitud detectados. Con
estos órdenes, realizamos un análisis entre la dependencia existente entre los errores, lo cual
permitió definir dos estrategias de reparación: reduce-delete-actions y reduce-insertion-actions.
La primera focaliza la reducción de la cantidad de información que es necesaria eliminar para
obtener un sitio Web libre de errores con respecto a su especificación. La segunda minimiza
la información que es necesaria insertar. Ambas estrategias explotan la dependencia existente
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
389
entre los errores, reparando todos sin más que actuar explícitamente sobre un subconjunto del
total de ellos.
La consideración de estas estrategias nos lleva a una optimización efectiva del proceso de
reaparación de un sitio Web; esto es debido a que el usuario debe de reparar una cantidad menor
de errores para obtener un sitio Web correcto y completo. Como trabajo futuro, pensamos en
la integración de estas estrategias de reparación en nuestro sistema WebVerdi-M [4] (disponible
en http://www.dsic.upv.es/users/elp/webverdi-m/). También hemos comenzado a explorar la
posibilidad de utilizar la interpretación abstracta para reducir el coste de la verificación y la
reparación.
References
1. S. Abiteboul, P. Buneman, and D. Suciu. Data on the Web. From Relations to Semistructured Data and XML.
Morgan Kaufmann, 2000.
2. M. Alpuente, D. Ballis, and M. Falaschi. Rule-based Verification of Web Sites. Software Tools for Technology
Transfer, 8:565–585, 2006.
3. M. Alpuente, D. Ballis, M. Falaschi, and D. Romero. A Semi-automatic Methodology for Reparing Faulty Web
Sites. In Proc. of the 4th IEEE Int’l Conference on Software Engineering and Formal Methods(SEFM’06), pages
31–40. IEEE Computer Society Press, 2006.
4. M. Alpuente, D. Ballis, M. Falaschi P. Ojeda, and D. Romero. A Fast Algebraic Web Verification Service. In Proc.
of First Int’l Conf. on Web Reasoning and Rule Systems (RR 2007), 2007. to appear.
5. F. Baader and T. Nipkow. Term Rewriting and All That. Cambridge University Press, 1998.
6. D. Ballis. Rule-based Software Verification and Correction. PhD thesis, University of Udine and Technical University
of Valencia, 2005.
7. D. Ballis and D. Romero. Fixing web sites using correction strategies. In Proc of 2nd Int’l Workshop on Automated
Specification and Verification of Web Systems (WWV’06). Paphos, Cyprus, pages 11–19. IEEE Computer Society
Press, 2007.
8. L. Bertossi and J. Pinto. Specifying Active Rules for Database Maintenance. In G. Saake, K. Schwarz, and C. Türker,
editors, Transactions and Database Dynamics, 8th Int’l Workshop on Foundations of Models and Languages for Data
and Objects, volume 1773 of Lecture Notes in Computer Science, pages 112–129. Springer, 1999.
9. M. Bezem. TeReSe, Term Rewriting Systems, chapter Mathematical background (Appendix A). Cambridge University Press, 2003.
10. F. Bry and S. Schaffert. Towards a Declarative Query and Transformation Language for XML and Semistructured
Data: Simulation Unification. In Proc. of the Int’l Conference on Logic Programming (ICLP’02), volume 2401 of
Lecture Notes in Computer Science. Springer-Verlag, 2002.
11. L. Capra, W. Emmerich, A. Finkelstein, and C. Nentwich. XLINKIT: a Consistency Checking and Smart Link
Generation Service. ACM Transactions on Internet Technology, 2(2):151–185, 2002.
12. N. Dershowitz and D. Plaisted. Rewriting. Handbook of Automated Reasoning, 1:535–610, 2001.
13. M. F. Fernandez and D. Suciu. Optimizing Regular Path Expressions Using Graph Schemas. In Proc. of Int’l Conf
on Data Engineering (ICDE’98), pages 14–23, 1998.
14. J.W. Klop. Term Rewriting Systems. In S. Abramsky, D. Gabbay, and T. Maibaum, editors, Handbook of Logic in
Computer Science, volume I, pages 1–112. Oxford University Press, 1992.
15. M. Leuschel. Homeomorphic Embedding for Online Termination of Symbolic Methods. In T. Æ. Mogensen, D. A.
Schmidt, and I. H. Sudborough, editors, The Essence of Computation, volume 2566 of LNCS, pages 379–403. Springer,
2002.
16. E. Mayol and E. Teniente. A Survey of Current Methods for Integrity Constraint Maintenance and View Updating.
In Proc. of Advances in Conceptual Modeling: ER ’99, volume 1727 of Lecture Notes in Computer Science, pages
62–73. Springer, 1999.
17. C. Nentwich, W. Emmerich, and A. Finkelstein. Consistency Management with Repair Actions. In Proc. of the 25th
International Conference on Software Engineering (ICSE’03). IEEE Computer Society, 2003.
18. Jan Scheffczyk, , Uwe M. Borghoff Peter Rödig, and Lothar Schmitz. S-dags: Towards efficient document repair
generation. In Proc. 2nd Int. Conf. on Computing, Communications and Control Technologies, volume 2, pages
308–313, 2004.
19. Jan Scheffczyk, Uwe M. Borghoff, Peter Rödig, and Lothar Schmitz. Consistent document engineering: formalizing
type-safe consistency rules for heterogeneous repositories. In Proc. of the 2003 ACM Symposium on Document
Engineering (DocEng ’03), pages 140–149. ACM Press, 2003.
20. Jan Scheffczyk, Peter Rödig, Uwe M. Borghoff, and Lothar Schmitz. Managing inconsistent repositories via prioritized
repairs. In Proc. of the 2004 ACM Symposium on Document Engineering (DocEng ’04), pages 137–146. ACM Press,
2004.
XIII Congreso Argentino de Ciencias de la Computación
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 
IV Workshop de Ingeniería de Software y Bases de Datos
_________________________________________________________________________
 
 
390
