Computo en paralelo para integrales multic√©ntricas usando una distribuci√≥n balanceada
ÔªøLa aproximaci√≥n del campo autoconsistente (SCF) es
utilizada en Quimica Computacional para abordar problemas de
Quimica Cu√°ntica. Entre otros, la energ√≠a molecular y la geometr√≠a
de equilibrio son elementos determinados al nivel SCF. El enfoque
SCF-LCAO presenta complejidad computacional, pues requiere gran
esfuerzo de c√°lculo. Hemos desarrollado un programa secuencial, que
posee caracter√≠sticas interesantes desde el punto de vista num√©rico, pero
con alto costo en tiempo computacional. Con el objetivo de reducir el
mismo se propuso paralelizar el algoritmo; actualmente se cuenta con
una primera propuesta paralela. En este trabajo se presenta una nueva
versi√≥n paralela del algoritmo, utilizando el modelo de comunicaci√≥n y
programaci√≥n basado en pasaje de mensajes, empleando una t√©cnica de
descomposici√≥n de datos que contempla una carga de trabajo ponderada
seg√∫n el costo computacional de cada funci√≥n. Los resultados obtenidos
con esta nueva versi√≥n resultan satisfactorios en cuanto a la reducci√≥n
del tiempo de c√≥mputo.
Keywords: C√°lculo Molecular, Aproximaci√≥n SCF-LCAO, Paralelizaci√≥n,
Balance de Carga.
1. El Tema en Estudio
Para conocer la estructura y las propiedades de una mol√©cula es necesario
estudiar la soluci√≥n de la ecuaci√≥n de Schr√∂dinger, independiente del tiempo:
306
HŒ® = EŒ® (1)
donde H es el operador Hamiltoniano, Œ® es la funci√≥n de onda que describe
el estado del sistema y E es la energ√≠a molecular. Se est√° interesado en
encontrar soluciones aproximadas para la ecuaci√≥n de autovalores (1), ya que la
misma no puede resolverse exactamente, salvo en casos simples [20]. Uno de los
procedimientos que se utiliza para obtener soluciones aproximadas est√° basado
en la teor√≠a de Hartree-Fock-Roothaan. A este procedimiento por ser iterativo
se lo denomina ‚Äúcampo autoconsistente‚Äù (Self Consistent Field), y por provenir
de combinaciones lineales de orbitales at√≥micos (Linear Combination of Atomic
Orbitals), se lo denota por las siglas en ingl√©s SCF-LCAO.
La complejidad computacional del m√©todo se centra en el gran n√∫mero de
integrales bielectr√≥nicas que se deben calcular, a√∫n en modelos de relativamente
bajo tama√±o. Este n√∫mero es del orden de n4, siendo n el n√∫mero de orbitales
que modelan la mol√©cula.
Debido a su popularidad, SCF ha sido constantemente estudiado y
optimizado para conseguir mejor desempe√±o computacional y hacer posible su
uso en el estudio de sistemas de mayor tama√±o. Los estudios realizados sobre el
m√©todo SCF cubren, entre otros, cuatro aspectos importantes:
Selecci√≥n de una base de orbitales at√≥micos adecuada. Bases que han sido
extensivamente estudiadas son las que incluyen orbitales at√≥micos tipo
Slater (STO) [1], [2], orbitales Gaussianos (GTO)[3] y B-funciones [4], [5].
Una variante de los GTO la constituyen los orbitales Gaussianos flotantes
(FGTO) [6],[7].
Desarrollo de los c√°lculos relativos a la base introducida. Es un hecho
ampliamente conocido que, cualquiera sea la base seleccionada, las integrales
bielectr√≥nicas resultantes, en la mayor√≠a de los casos, no se pueden resolver
en forma anal√≠tica. Por lo tanto, es necesario calcularlas num√©ricamente por
m√©todos aproximados [8], [9], [10],[11], [12].
Implementaci√≥n de programas computacionales tendientes a obtener informaci√≥n sobre diferentes propiedades moleculares. En los √∫ltimos a√±os se han
desarrollado varios programas, algunos comerciales, otros desarrollados en
centros cient√≠ficos, los cuales realizan c√°lculos moleculares de distintos tipos.
Sus implementaciones pueden ser seriales o en paralelo y sus capacidades
de c√°lculo son diversas. Gaussian [25] es uno de los m√°s difundidos. Otras
alternativas se encuentran en [13], [14], [15].
Aplicaci√≥n de los programas para el estudio de sistemas concretos. Esta
es un √°rea muy activa de trabajo. Un punto importante en este campo
es el desarrollo de heur√≠sticas que sirvan de guia para la ubicaci√≥n de los
orbitales at√≥micos, tendientes a reproducir adecuadamente comportamientos
que se conocen desde un punto de vista quimico. No menos importante es el
desarrollo de estrategias que permitan combinar estructuras simples resueltas
para modelar sistemas m√°s complejos [16], [17], [18], [19].
307
2. El Algoritmo de C√°lculo SCF-LCAO (rasgos generales)
El algoritmo de c√°lculo que computa la aproximaci√≥n SCF-LCAO permite
utilizar distintos modelos de bases at√≥micas. A continuaci√≥n se presenta de
manera general, el esquema de procesamiento del algoritmo (para obtener un
detalle completo del algoritmo y cada una de sus partes, ver [20]):
1. El programa requiere como dato de entrada una geometr√≠a inicial de la
mol√©cula a optimizar (coordenadas nucleares y el n√∫mero de electrones).
2. Se calculan todas las integrales moleculares requeridas: S¬µŒΩ , H¬µŒΩ , (¬µŒΩ|œÉŒª).
3. Diagonalizar la matriz de overlap S y obtener la matriz de transformaci√≥n
X.
4. Obtener la matriz de densidad P.
5. Calcular la matriz G, a partir de la matriz de densidad P y de las integrales
bielectr√≥nicas (¬µŒΩ|œÉŒª).
6. Obtener F = H + G
7. Calcular F‚Ä≤ = X‚àóFX
8. Diagonalizar F‚Ä≤, para obtener C‚Ä≤ y , y calcular C = XC‚Ä≤
9. Cuando se comprueba la convergencia, el proceso finaliza, caso contrario
vuelve a 4.
Con este algoritmo se obtiene la geometr√≠a molecular √≥ptima minimizando la
energ√≠a. Para ello, se realiza el c√°lculo anterior en diferentes posiciones relativas
de los √°tomos.
3. Desarrollo de la investigaci√≥n
El grupo de investigaci√≥n desarroll√≥ en una primera etapa una propuesta
secuencial del algoritmo mencionado, el cual logra la optimizaci√≥n de geometr√≠as
moleculares a trav√©s de la minimizaci√≥n de la energ√≠a. Uno de los problemas de
esa versi√≥n algor√≠tmica es el alto tiempo de c√≥mputo insumido, raz√≥n por la cual
se han intentado diferentes alternativas a fin de mejorar esta implementaci√≥n.
Una l√≠nea de trabajo estudia, fundamentalmente, variantes en las t√©cnicas de
c√°lculo para el algoritmo que modela el problema [16],[17],[18],[19],[26], [27], [28].
Otra se enfoca en paralelizar el algoritmo secuencial. Se trabaj√≥ inicialmente
en paralelizar una regla de cuadratura gaussiana [30]. Posteriormente, se
paraleliz√≥ una parte del algoritmo secuencial en el cual se distribuyen los c√°lculos
intermedios en diferentes unidades de procesamiento, con una distribuci√≥n de
carga fija [29]; obteni√©ndose mejoras respecto de los tiempos secuenciales y un
buen balance de carga para el caso de prueba utilizado.
En este trabajo, se presenta una modificaci√≥n de la √∫ltima versi√≥n paralela,
respecto del mecanismo de asignaci√≥n de carga a cada unidad de procesamiento.
Aqui, la distribuci√≥n se realiza en funci√≥n de un peso asociado al tipo de c√°lculo
a realizar. A diferencia de la versi√≥n anterior, esta nueva propuesta considera las
particularidades de la mol√©cula. Con este esquema, se posee mayor control del
costo computacional en relaci√≥n al ejemplo en estudio.
A continuaci√≥n daremos una descripci√≥n de la base de funciones utilizadas en
la implementaci√≥n, y posteriormente presentaremos la nueva versi√≥n paralela.
308
4. Funciones utilizadas en la modelizaci√≥n
Una buena base de orbitales at√≥micos debe satisfacer dos condiciones para dar
soluciones apropiadas. Dichas condiciones vienen dadas por el ‚Äúcomportamiento
cuspidal alrededor de los n√∫cleos‚Äù y el ‚Äúdecaimiento exponencial‚Äù en el infinito
[21].
En el desarrollo del programa secuencial se utiliz√≥ una base de funciones,
con orbitales at√≥micos 1s de Slater (STO) y gaussianos (GTO). Dichos orbitales
tienen las siguientes expresiones:
Œ¶¬µ(
‚Üí
r ) = C ‚Äòe(‚àíŒ±¬µ|
‚Üí
r‚àí
‚Üí
R¬µ|) (STO)
Œ¶¬µ(
‚Üí
r ) = Ce(‚àíŒ±¬µ|
‚Üí
r‚àí
‚Üí
R¬µ|
2) (GTO)
donde C = ( 2Œ±¬µpi )
3/4, C ‚Äò = (
Œ±3¬µ
pi )
1/2,
‚Üí
r pertenece a R3, el vector
‚Üí
R¬µ se denomina
centro del orbital y Œ±¬µ es el coeficiente orbital.
Las funciones GTO antes mencionadas, a pesar de no satisfacer la condici√≥n
de comportamiento cuspidal alrededor de los n√∫cleos, son las m√°s utilizadas,
puesto que las integraciones necesarias se realizan eficientemente. En contraste,
las funciones STO satisfacen ambas condiciones, pero los c√°lculos de las
integraciones son computacionalmente costosas.
En la implementaci√≥n secuencial realizada, la mayor parte del tiempo de
c√°lculo insumido lo requiere la evaluaci√≥n del potencial promedio de HartreeFock, pues cuando se introduce la base at√≥mica, hay que evaluar integrales
bielectr√≥nicas multic√©ntricas que tienen la siguiente expresi√≥n:
(¬µŒΩ|œÉŒª) =
‚à´ ‚à´
R3√óR3
Œ¶¬µ(
‚Üí
r1)Œ¶ŒΩ(
‚Üí
r1)
1
|
‚Üí
r1 ‚àí
‚Üí
r2 |
Œ¶œÉ(
‚Üí
r2)Œ¶Œª(
‚Üí
r2)d
‚Üí
r1 d
‚Üí
r2 (2)
donde los √≠ndices a = ¬µ, ŒΩ, œÉ y Œª corresponden a las funciones Œ¶a(
‚Üí
ri) de la base
dadas por los orbitales (STO) y (GTO). A la expresi√≥n (¬µŒΩ|œÉŒª) la llamamos
cantidad de cuatro √≠ndices.
Esta particularidad de utilizar una base formada por dos clases de funciones
es lo que diferencia nuestra implementaci√≥n de otras, como por ejemplo las que
se utilizan en el programa de c√≥mputo Gaussian [25].
En nuestra implementaci√≥n, los orbitales STO se posicionan en los n√∫cleos,
para modelar el correcto comportamiento de la funci√≥n de onda. Los orbitales
GTO pueden ser colocados en los n√∫cleos o en los enlaces que unen dos n√∫cleos.
Los resultados obtenidos mediante esta modelizaci√≥n han sido competitivos en
cuanto a la geometr√≠a y a las cifras significativas.
En estos c√≥mputos cuando Œ¶¬µ, Œ¶ŒΩ , Œ¶œÉ y Œ¶Œª son de tipo GTO, la integral de
la f√≥rmula (2) posee una primitiva conocida, por lo que su c√°lculo es directo. En
aquellos casos en los que la expresi√≥n (2) utiliza al menos una funci√≥n del tipo
STO, el c√≥mputo requiere la aproximaci√≥n num√©rica de las integrales, pues ellas
no tienen expresi√≥n anal√≠tica [9]. Estas integrales pueden ser unidimensionales,
bidimensionales o tridimensionales.
309
5. Modelo de C√≥mputo en Paralelo
5.1. El Programa
En nuestro programa secuencial, el c√≥mputo de las integrales de cuatro
√≠ndices de la f√≥rmula (2) guia su procesamiento a trav√©s de un vector, en el cual
se disponen todas las combinaciones de funciones a evaluar. Estas combinaciones
de funciones son independientes unas de otras, por lo cual es posible aplicar un
esquema de paralelizaci√≥n directo.
La primera versi√≥n de la implementaci√≥n en paralelo consideraba, para la
distribuci√≥n de carga, s√≥lo la cantidad de funciones involucradas en el c√°lculo,
de manera de asignar cierto porcentaje de esas funciones a cada procesador. En
nuestro problema las funciones no poseen la misma complejidad computacional,
por lo cual, el tiempo que requiere su procesamiento es variable. Para compensar
esta variabilidad, en esta primera versi√≥n paralela se consideraron porcentajes
no equitativos en la distribuci√≥n de carga. En una bater√≠a de pruebas se
utilizaron diferentes valores para estos porcentajes de manera tal de analizar el
comportamiento del algoritmo con este esquema de paralelizaci√≥n ad-hoc. Con
esta distribuci√≥n se obtuvieron resultados aceptables en cuanto a la reducci√≥n
del tiempo de c√≥mputo, manteniendo la calidad de la aproximaci√≥n [29]. Sin
embargo, esta distribuci√≥n de carga resulta ser m√°s adecuada cuando el costo
computacional de cada una de las funciones es equitativo.
La nueva versi√≥n del programa paralelo, al igual que en la versi√≥n anterior,
sigue un modelo algor√≠tmico master-worker [22], en donde el proceso master es
el encargado de inicializar los c√°lculos, generar las matrices iniciales y preparar
los datos para distribuir el c√≥mputo entre los procesadores workers. Luego de
finalizar el procesamiento que les fue asignado, los workers retornan al proceso
master sus resultados parciales, para que √©ste √∫tlimo obtenga la soluci√≥n final.
En esta segunda versi√≥n se realiza la distribuci√≥n de carga clasificando
cada funci√≥n seg√∫n el costo computacional del trabajo matem√°tico involucrado,
par√°metro que llamamos peso. A partir de esto se distribuyen los c√°lculos
utilizando como criterio el balance de la suma de los pesos, en lugar de considerar
solamente la cantidad de funciones.
Para la ponderaci√≥n, el c√°lculo de coeficientes (¬µ¬µ|ŒΩŒΩ) de las cantidades de
cuatro √≠ndices que involucra solo funciones de tipo STO (en centros distintos
o centros coincidentes), y todas las cantidades de cuatro √≠ndices donde solo
intervienen funciones GTO, requieren operaciones de suma, multiplicaci√≥n y
evaluaci√≥n de funciones simples, siendo estos los coeficientes de menor costo
computacional. A los mismos les asignamos el menor peso.
El c√°lculo de coeficientes (¬µŒΩ|œÉŒª), con todas funciones de tipo STO, donde
todos los √≠ndices son distintos, involucra adem√°s de las operaciones elementales,
la evaluaci√≥n de una integral triple, que es aproximada usando la regla de
cuadratura de Gauss-Legendre con 32 puntos en cada variable. A estos c√°lculos,
que requieren el mayor costo computacional, le asignamos el mayor peso.
310
Como el peso de cada funci√≥n dependen del tipo de c√°lculo a realizar y no
de una mol√©cula y/o funci√≥n en particular, los mismos pueden establecerse en
forma previa a la ejecuci√≥n del programa.
Si bien se conoce la complejidad computacional de cada funci√≥n, la cantidad
y el tipo de funciones de la base que modelan una mol√©cula var√≠a de acuerdo al
compuesto quimico que se est√© abordando. Por este motivo, se intenta obtener
un esquema de mapeo din√°mico, en el sentido de establecer que el proceso master
determine, considerando el peso y la cantidad de funciones, cu√°l/les son las tareas
asignadas a cada worker.
La vesi√≥n paralela utiliza el lenguaje Octave [24], software libre de c√°lculos
num√©ricos. Se decidi√≥ utilizar un modelo de comunicaci√≥n y programaci√≥n basado
en pasaje de mensajes, bajo una organizaci√≥n de memoria distribuida [22]. Para
su implementaci√≥n se emple√≥ la librer√≠a MPI [23], en conjunto con el lenguaje de
programaci√≥n C. Se utilizaron paquetes adicionales para invocar, desde el c√≥digo
escrito en el lenguaje C, rutinas escritas en Octave (mex-interface) [24].
5.2. Los Ensayos y Resultados
A continuaci√≥n se muestra un ejemplo de una mol√©cula donde se fijan sobre
los n√∫cleos las funciones STO y s√≥lo se var√≠a la cantidad de funciones GTO. Las
funciones STO utilizadas en las pruebas se centraron en los siguientes n√∫cleos:
‚àí‚Üí
R¬µ = (0, 1,4296, 1,1124),
‚àí‚Üí
RŒΩ = (0,‚àí1,4296, 1,1124),
‚àí‚Üí
RœÉ = (0, 0, 0) con coeficientes orbitales Œ±¬µ = 1, Œ±ŒΩ = 1, Œ±œÉ = 8
Modelo Total de Funciones Tiempo Secuencial Tiempo Paralelo
1 15 0m 9.07s 0m 7.85s
(3 STO, 12 GTO)
2 25 3m 55.62s 1m 41.68s
(3 STO, 22 GTO)
3 50 750m 20.34s 350m 49.79s
(3 STO, 47 GTO)
Cuadro 1. Tiempos de ejecuci√≥n con las dos versiones algor√≠tmicas.
El cuadro 1 muestra las aceleraciones obtenidas con la m√°xima capacidad
de c√°lculo disponible. Se contrastan en la misma los tiempos obtenidos con el
programa secuencial, incluyendo tres modelos distintos de la misma mol√©cula. Se
311
puede observar, en todas las ejecuciones, que la versi√≥n paralela obtiene menores
tiempos de c√≥mputo.
15 20 25 30 35 40 45 500
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5 x 104
Cantidad de funciones
Tiem
po
secuencialparalelo
Figura 1. Tiempo de ejecuci√≥n (en segundo) vs cantidad de funciones de la mol√©cula.
Se puede observar que el modelo secuencial insume m√°s tiempo de c√≥mputo que el
modelo paralelo. La tendencia indicar√≠a que al aumentar la cantidad de funciones que
modelan la mol√©cula, el modelo paralelo sigue teniendo mejor desempe√±o.
15 20 250
50
100
150
200
250
Cantidad de funciones
Tiem
po
secuencialparalelo
Figura 2. Tiempo de ejecuci√≥n (en segundos) vs cantidad de funciones de la mol√©cula.
En esta figura se muestra en detalle el primer intervalo de la Figura 1, donde se puede
constatar un comportamiento similiar al descripto anteriormente para mol√©culas que
utilizan entre 15 y 25 funciones en su modelado.
Las Figuras 1 y 2 grafican el comportamiento de los valores obtenidos en la
tabla 1.
Las pruebas piloto fueron llevadas a cabo utilizando una computadora con
procesador Intel(R) Core(TM) i7-2600, con 8 procesos workers m√°s un proceso
adicional asignado al master. Si bien el c√≥digo est√° preparado para realizar
312
pruebas en un entorno real de memoria distribuida, como por ejemplo un cluster
de computadores, al momento disponemos solamente del recurso mencionado.
6. Reflexiones Finales
En este trabajo se presenta una nueva versi√≥n paralela de un programa
secuencial dedicado al c√°lculo molecular, para determinar la funci√≥n de onda
y la m√≠nima energ√≠a en la aproximaci√≥n SCF-LCAO. Esta versi√≥n considera,
para la distribuci√≥n del trabajo, la suma de los pesos relativos de cada funci√≥n
involucrada en el c√°lculo. Con ella se obtuvieron buenos resultados en cuanto a
reducci√≥n del tiempo de c√≥mputo, manteniendo la calidad de la aproximaci√≥n.
Las pruebas realizadas a√∫n no fueron escaladas a mayor cantidad de
procesadores, por ejemplo, a trav√©s de la utilizaci√≥n de clusters. Como trabajo
futuro se planea la ejecuci√≥n del c√≥digo desarrollado en un entorno con mayor
cantidad de unidades de c√≥mputo. A la vez se espera desarrollar una nueva
versi√≥n paralela, considerando un modelo de asignaci√≥n de tareas y balance de
carga din√°mico, en el cual los procesos worker tomen los trabajos a partir de un
pool de tareas. Con este nuevo enfoque se intentar√° desarrollar un modelo que
continue considerando la carga de trabajo variable en cada unidad de c√°lculo.
Agradecimientos
A la Secretar√≠a de Ciencia y T√©cnica de la Universidad Nacional de R√≠o
Cuarto, y al Ministerio de Ciencia y Tecnolog√≠a de la Provincia de C√≥rdoba, por
los recursos puestos a nuestra disposici√≥n para llevar adelante esta investigaci√≥n.
